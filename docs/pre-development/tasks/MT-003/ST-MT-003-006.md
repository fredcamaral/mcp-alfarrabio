# ST-MT-003-006: Implement Integration Tests and Network Resilience

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-003-006
- **Sub-Task Name:** Implement Integration Tests and Network Resilience
- **Parent Task:** MT-003: Bidirectional Server Integration and Real-Time Sync
- **Estimated Duration:** 3 hours
- **Implementation Type:** Testing

## 2. Deliverable Specification
- **Primary Output:** Comprehensive integration test suite and network resilience mechanisms
- **Code Location:** 
  - `internal/adapters/api/tests/integration/` - Server integration tests
  - `cli/tests/integration/sync_test.go` - CLI sync integration tests
  - `internal/adapters/api/middleware/circuit_breaker.go` - Circuit breaker
  - `tests/e2e/bidirectional_sync_test.go` - End-to-end sync tests
- **Technical Requirements:** Integration test framework, network simulation, resilience patterns
- **Interface Definition:** Test suite validating complete sync system

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Setup integration test environment with test containers
  2. Create server API integration tests
  3. Implement WebSocket connection tests
  4. Add CLI-to-server sync tests
  5. Create network failure simulation tests
  6. Implement circuit breaker middleware
  7. Add connection retry and backoff tests
  8. Create conflict resolution test scenarios
  9. Implement performance and load tests
  10. Add end-to-end sync validation tests

- **Code Examples:**
  ```go
  // Integration test setup
  package integration
  
  import (
      "context"
      "testing"
      "time"
      
      "github.com/stretchr/testify/suite"
      "github.com/testcontainers/testcontainers-go"
      "github.com/testcontainers/testcontainers-go/wait"
  )
  
  type SyncIntegrationSuite struct {
      suite.Suite
      serverContainer testcontainers.Container
      qdrantContainer testcontainers.Container
      serverURL       string
      wsURL           string
      httpServer      *api.HTTPServer
      testStorage     storage.TaskStorage
  }
  
  func (s *SyncIntegrationSuite) SetupSuite() {
      ctx := context.Background()
      
      // Start Qdrant container
      qdrantReq := testcontainers.ContainerRequest{
          Image:        "qdrant/qdrant:latest",
          ExposedPorts: []string{"6333/tcp"},
          WaitingFor:   wait.ForHTTP("/").WithPort("6333/tcp"),
      }
      
      qdrant, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
          ContainerRequest: qdrantReq,
          Started:          true,
      })
      s.Require().NoError(err)
      s.qdrantContainer = qdrant
      
      // Get Qdrant URL
      qdrantHost, err := qdrant.Host(ctx)
      s.Require().NoError(err)
      qdrantPort, err := qdrant.MappedPort(ctx, "6333")
      s.Require().NoError(err)
      
      // Setup test server
      config := &api.ServerConfig{
          Port:              0, // Random port
          RateLimitRequests: 100,
          RateLimitWindow:   time.Minute,
      }
      
      s.testStorage = storage.NewQdrantStorage(fmt.Sprintf("http://%s:%s", qdrantHost, qdrantPort.Port()))
      s.httpServer = api.NewHTTPServer(config, s.testStorage, slog.Default())
      
      // Start server
      go s.httpServer.Start(context.Background())
      time.Sleep(100 * time.Millisecond) // Wait for server to start
      
      s.serverURL = fmt.Sprintf("http://localhost:%d", s.httpServer.Port())
      s.wsURL = fmt.Sprintf("ws://localhost:%d", s.httpServer.Port())
  }
  
  func (s *SyncIntegrationSuite) TearDownSuite() {
      ctx := context.Background()
      s.httpServer.Shutdown(ctx)
      s.qdrantContainer.Terminate(ctx)
  }
  
  // Test bidirectional sync
  func (s *SyncIntegrationSuite) TestBidirectionalSync() {
      ctx := context.Background()
      
      // Create CLI client
      httpClient := api.NewHTTPClient(s.serverURL, "1.0.0", slog.Default())
      wsClient := api.NewWebSocketClient(s.wsURL, "1.0.0", nil, slog.Default())
      
      // Connect WebSocket
      err := wsClient.Connect(ctx)
      s.Require().NoError(err)
      defer wsClient.Close()
      
      // Subscribe to test repository
      err = wsClient.SubscribeToRepositories([]string{"test-repo"})
      s.Require().NoError(err)
      
      // Setup notification capture
      notifications := make(chan api.TaskEvent, 10)
      wsClient.SetNotificationHandler(func(event api.TaskEvent) {
          notifications <- event
      })
      
      // Create task via HTTP API
      createReq := &models.CreateTaskRequest{
          Content:    "Test task for sync",
          Priority:   "high",
          Repository: "test-repo",
      }
      
      taskResp, err := httpClient.CreateTask(ctx, createReq)
      s.Require().NoError(err)
      s.Assert().NotEmpty(taskResp.ID)
      
      // Wait for WebSocket notification
      select {
      case event := <-notifications:
          s.Assert().Equal(api.EventTypeTaskCreated, event.Type)
          s.Assert().Equal(taskResp.ID, event.TaskID)
          s.Assert().Equal("test-repo", event.Repository)
      case <-time.After(2 * time.Second):
          s.Fail("Timeout waiting for WebSocket notification")
      }
      
      // Update task
      updateReq := &models.UpdateTaskRequest{
          Status: stringPtr("in_progress"),
      }
      
      updated, err := httpClient.UpdateTask(ctx, taskResp.ID, updateReq)
      s.Require().NoError(err)
      s.Assert().Equal("in_progress", updated.Status)
      
      // Wait for update notification
      select {
      case event := <-notifications:
          s.Assert().Equal(api.EventTypeTaskUpdated, event.Type)
          s.Assert().Equal(taskResp.ID, event.TaskID)
      case <-time.After(2 * time.Second):
          s.Fail("Timeout waiting for update notification")
      }
  }
  
  // Test network resilience
  func (s *SyncIntegrationSuite) TestNetworkResilience() {
      ctx := context.Background()
      
      // Create proxy to simulate network issues
      proxy := toxiproxy.NewProxy()
      proxy.Name = "test-proxy"
      proxy.Listen = "127.0.0.1:0"
      proxy.Upstream = s.serverURL
      
      err := proxy.Start()
      s.Require().NoError(err)
      defer proxy.Stop()
      
      proxyURL := fmt.Sprintf("http://%s", proxy.Listen)
      
      // Create client through proxy
      httpClient := api.NewHTTPClient(proxyURL, "1.0.0", slog.Default())
      
      // Add latency toxic
      latencyToxic := proxy.Toxics.Add("latency", "latency", "downstream", 1.0, toxiproxy.Attributes{
          "latency": 500,
          "jitter":  100,
      })
      
      // Should still work with latency
      createReq := &models.CreateTaskRequest{
          Content:    "Test with latency",
          Priority:   "medium",
          Repository: "test-repo",
      }
      
      start := time.Now()
      _, err = httpClient.CreateTask(ctx, createReq)
      s.Require().NoError(err)
      s.Assert().Greater(time.Since(start), 400*time.Millisecond)
      
      // Add timeout toxic
      proxy.Toxics.Add("timeout", "timeout", "downstream", 1.0, toxiproxy.Attributes{
          "timeout": 100,
      })
      
      // Should retry and succeed
      _, err = httpClient.CreateTask(ctx, createReq)
      s.Assert().NoError(err) // Retry should handle timeout
      
      // Test connection interruption
      latencyToxic.Delete()
      
      // Add bandwidth limit
      proxy.Toxics.Add("bandwidth", "bandwidth", "downstream", 1.0, toxiproxy.Attributes{
          "rate": 1000, // 1KB/s
      })
      
      // Large request should still work (with patience)
      largeReq := &models.CreateTaskRequest{
          Content:    strings.Repeat("x", 10000), // 10KB content
          Priority:   "low",
          Repository: "test-repo",
      }
      
      ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
      defer cancel()
      
      _, err = httpClient.CreateTask(ctx, largeReq)
      s.Assert().NoError(err)
  }
  
  // Test conflict resolution
  func (s *SyncIntegrationSuite) TestConflictResolution() {
      ctx := context.Background()
      
      // Create two clients simulating different CLI instances
      client1 := api.NewHTTPClient(s.serverURL, "1.0.0", slog.Default())
      client2 := api.NewHTTPClient(s.serverURL, "1.0.0", slog.Default())
      
      // Create task
      createReq := &models.CreateTaskRequest{
          Content:    "Original content",
          Priority:   "medium",
          Repository: "test-repo",
      }
      
      task, err := client1.CreateTask(ctx, createReq)
      s.Require().NoError(err)
      
      // Both clients update simultaneously
      update1 := &models.UpdateTaskRequest{
          Content: stringPtr("Updated by client 1"),
      }
      
      update2 := &models.UpdateTaskRequest{
          Content: stringPtr("Updated by client 2"),
      }
      
      // Client 1 updates
      _, err = client1.UpdateTask(ctx, task.ID, update1)
      s.Require().NoError(err)
      
      // Client 2 updates (should create conflict)
      _, err = client2.UpdateTask(ctx, task.ID, update2)
      s.Require().NoError(err)
      
      // Perform batch sync to resolve
      batchClient := api.NewBatchClient(s.serverURL, "1.0.0", slog.Default())
      
      syncReq := &models.BatchSyncRequest{
          Repository: "test-repo",
          LocalTasks: []models.TaskSyncItem{{
              ID:           task.ID,
              Content:      "Local different content",
              Status:       "pending",
              Priority:     "high",
              UpdatedAt:    time.Now(),
              LocalVersion: 3,
          }},
      }
      
      syncResp, err := batchClient.BatchSync(ctx, syncReq)
      s.Require().NoError(err)
      
      // Should have conflict
      s.Assert().Len(syncResp.Conflicts, 1)
      s.Assert().Equal("server_wins", syncResp.Conflicts[0].Resolution.Strategy)
  }
  
  // Circuit breaker implementation
  package middleware
  
  type CircuitBreaker struct {
      maxFailures  int
      resetTimeout time.Duration
      halfOpenMax  int
      
      failures     int
      lastFailTime time.Time
      state        State
      mu           sync.Mutex
  }
  
  type State int
  
  const (
      StateClosed State = iota
      StateOpen
      StateHalfOpen
  )
  
  func NewCircuitBreaker(maxFailures int, resetTimeout time.Duration) *CircuitBreaker {
      return &CircuitBreaker{
          maxFailures:  maxFailures,
          resetTimeout: resetTimeout,
          halfOpenMax:  maxFailures / 2,
          state:        StateClosed,
      }
  }
  
  func (cb *CircuitBreaker) Middleware(next http.Handler) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          if !cb.Allow() {
              http.Error(w, "Service temporarily unavailable", http.StatusServiceUnavailable)
              return
          }
          
          // Wrap response writer to capture status
          ww := &responseWriter{ResponseWriter: w}
          next.ServeHTTP(ww, r)
          
          // Record result
          if ww.status >= 500 {
              cb.RecordFailure()
          } else {
              cb.RecordSuccess()
          }
      })
  }
  
  func (cb *CircuitBreaker) Allow() bool {
      cb.mu.Lock()
      defer cb.mu.Unlock()
      
      now := time.Now()
      
      switch cb.state {
      case StateClosed:
          return true
          
      case StateOpen:
          if now.Sub(cb.lastFailTime) > cb.resetTimeout {
              cb.state = StateHalfOpen
              cb.failures = 0
              return true
          }
          return false
          
      case StateHalfOpen:
          return cb.failures < cb.halfOpenMax
      }
      
      return false
  }
  
  // Performance test
  func (s *SyncIntegrationSuite) TestSyncPerformance() {
      ctx := context.Background()
      
      // Create many tasks
      const numTasks = 1000
      tasks := make([]*models.TaskResponse, 0, numTasks)
      
      httpClient := api.NewHTTPClient(s.serverURL, "1.0.0", slog.Default())
      
      start := time.Now()
      
      // Create tasks in parallel
      var wg sync.WaitGroup
      taskChan := make(chan *models.TaskResponse, numTasks)
      
      for i := 0; i < 10; i++ {
          wg.Add(1)
          go func(workerID int) {
              defer wg.Done()
              
              for j := 0; j < numTasks/10; j++ {
                  req := &models.CreateTaskRequest{
                      Content:    fmt.Sprintf("Task %d-%d", workerID, j),
                      Priority:   "medium",
                      Repository: "perf-test",
                  }
                  
                  task, err := httpClient.CreateTask(ctx, req)
                  if err == nil {
                      taskChan <- task
                  }
              }
          }(i)
      }
      
      wg.Wait()
      close(taskChan)
      
      for task := range taskChan {
          tasks = append(tasks, task)
      }
      
      createDuration := time.Since(start)
      s.T().Logf("Created %d tasks in %v (%.0f tasks/sec)", 
          len(tasks), createDuration, float64(len(tasks))/createDuration.Seconds())
      
      // Test batch sync performance
      batchClient := api.NewBatchClient(s.serverURL, "1.0.0", slog.Default())
      
      syncItems := make([]models.TaskSyncItem, 0, len(tasks))
      for _, task := range tasks {
          syncItems = append(syncItems, models.TaskSyncItem{
              ID:        task.ID,
              Content:   task.Content,
              Status:    task.Status,
              Priority:  task.Priority,
              UpdatedAt: task.UpdatedAt,
          })
      }
      
      syncReq := &models.BatchSyncRequest{
          Repository: "perf-test",
          LocalTasks: syncItems,
      }
      
      start = time.Now()
      syncResp, err := batchClient.BatchSync(ctx, syncReq)
      s.Require().NoError(err)
      
      syncDuration := time.Since(start)
      s.T().Logf("Synced %d tasks in %v", len(syncItems), syncDuration)
      
      // Performance assertions
      s.Assert().Less(createDuration, 30*time.Second, "Creation should be under 30s")
      s.Assert().Less(syncDuration, 5*time.Second, "Sync should be under 5s")
      s.Assert().Len(syncResp.Conflicts, 0, "No conflicts expected")
  }
  
  func TestSyncIntegration(t *testing.T) {
      suite.Run(t, new(SyncIntegrationSuite))
  }
  ```

- **Configuration Changes:** 
  - Add test environment configuration
  - Configure circuit breaker thresholds
  - Set performance test parameters

- **Dependencies:**
  - `github.com/testcontainers/testcontainers-go`
  - `github.com/Shopify/toxiproxy-go` (for network simulation)
  - Existing test frameworks

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Complete sync flow tested end-to-end
  - Network failures handled gracefully
  - WebSocket reconnection tested
  - Conflict resolution validated
  - Performance meets requirements
  - Circuit breaker protects server
  - All edge cases covered
  
- **Technical Criteria:**
  - Tests run in isolated containers
  - Network conditions simulated accurately
  - Performance benchmarks established
  - Test coverage â‰¥90% for sync code
  - Tests complete in reasonable time
  
- **Integration Criteria:**
  - Tests validate all MT-003 components
  - MCP compatibility verified
  - Multi-client scenarios tested
  
- **Test Criteria:**
  - All test scenarios pass consistently
  - Performance tests establish baselines
  - Network resilience proven
  - No flaky tests

## 5. Testing Requirements
- **Unit Tests:**
  - Circuit breaker state transitions
  - Retry logic with backoff
  - Connection pool management
  - Error handling paths
  
- **Integration Tests:**
  - Full sync workflow
  - WebSocket lifecycle
  - Batch operations
  - Conflict scenarios
  - Network failures
  
- **Performance Tests:**
  - Large batch sync
  - Concurrent connections
  - Sustained load
  - Memory usage
  
- **Test Data:**
  - Various task datasets
  - Network condition profiles
  - Conflict scenarios

## 6. Definition of Done
- **Code Complete:** All integration tests and resilience features implemented
- **Tests Passing:** All test scenarios passing consistently (100% pass rate)
- **Documentation Updated:** Test scenarios and resilience patterns documented
- **Integration Verified:** Complete MT-003 functionality validated
- **Review Approved:** Test coverage and resilience strategies reviewed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** All previous MT-003 sub-tasks must be complete
- **External Dependencies:** Test containers, network simulation tools
- **Environmental Requirements:** Docker for test containers
- **Potential Blockers:** CI/CD environment limitations

## 8. Integration Notes
- **Component Interfaces:** Tests all MT-003 components together
- **Data Flow:** Complete sync flow validated end-to-end
- **Error Handling:** All failure modes tested and handled
- **Configuration Impact:** Test-specific configuration profiles