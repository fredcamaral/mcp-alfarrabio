# ST-MT-003-004: Implement CLI HTTP Client and Push Notifications

## Status
- **Status:** âœ… COMPLETED
- **Completion Date:** 2025-01-09
- **Implementation:** Successfully implemented WebSocket client, notification service, and sync manager in `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/cli/internal/adapters/secondary/`
- **Actual Implementation:** Full-featured HTTP MCP client with WebSocket real-time updates, notification service, and coordinated sync management
- **Deviations:** Implemented comprehensive WebSocket client with automatic reconnection, sophisticated notification service with CLI integration, and advanced sync manager with conflict resolution
- **Next Steps:** None - all features implemented including security fixes for gosec compliance

## IMPLEMENTATION STATUS: âœ… COMPLETED

**What was implemented:**
- âœ… HTTP-based MCP client in `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/cli/internal/adapters/secondary/mcp/client.go`
- âœ… WebSocket client with automatic reconnection and real-time updates
- âœ… Notification service for displaying real-time task events in CLI
- âœ… Sync manager for coordinating HTTP and WebSocket communications
- âœ… Comprehensive retry logic with exponential backoff
- âœ… Connection health monitoring with periodic checks
- âœ… Task synchronization via JSON-RPC over HTTP and WebSocket
- âœ… Online/offline state management with graceful degradation
- âœ… Error handling and timeout management
- âœ… Server configuration support with multiple transport protocols
- âœ… Push notification display system for REPL mode
- âœ… Repository-based subscriptions for targeted updates
- âœ… Conflict resolution with server as authoritative source
- âœ… Offline operation queuing and sync when reconnected
- âœ… Security fixes for gosec compliance (input validation, secure connections)

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-003-004
- **Sub-Task Name:** Implement CLI HTTP Client and Push Notifications
- **Parent Task:** MT-003: Bidirectional Server Integration and Real-Time Sync
- **Estimated Duration:** 3 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** CLI HTTP client for API communication and WebSocket client for real-time updates
- **Code Location:** 
  - `cli/internal/adapters/secondary/api/http_client.go` - HTTP API client
  - `cli/internal/adapters/secondary/api/websocket_client.go` - WebSocket client
  - `cli/internal/adapters/secondary/api/sync_manager.go` - Sync orchestration
  - `cli/internal/domain/services/notification_service.go` - Push notification handling
- **Technical Requirements:** HTTP client with retry logic, WebSocket client, notification display
- **Interface Definition:** API client interface for task operations with real-time sync

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create HTTP client with version headers and retry logic
  2. Implement task CRUD methods using HTTP API
  3. Create WebSocket client for real-time updates
  4. Implement automatic reconnection logic
  5. Create sync manager to coordinate HTTP and WebSocket
  6. Add notification service for displaying updates
  7. Implement conflict resolution with server as truth
  8. Add connection status monitoring
  9. Create offline queue for failed operations
  10. Integrate with existing CLI commands

- **Code Examples:**
  ```go
  // HTTP API client
  package api
  
  import (
      "bytes"
      "context"
      "encoding/json"
      "fmt"
      "net/http"
      "time"
      
      "github.com/hashicorp/go-retryablehttp"
  )
  
  type HTTPClient struct {
      baseURL    string
      httpClient *retryablehttp.Client
      version    string
      logger     *slog.Logger
  }
  
  type APIError struct {
      Error     string `json:"error"`
      Message   string `json:"message"`
      RequestID string `json:"request_id"`
  }
  
  func NewHTTPClient(baseURL, version string, logger *slog.Logger) *HTTPClient {
      retryClient := retryablehttp.NewClient()
      retryClient.RetryMax = 3
      retryClient.RetryWaitMin = 1 * time.Second
      retryClient.RetryWaitMax = 5 * time.Second
      retryClient.Logger = nil // Use our logger
      
      return &HTTPClient{
          baseURL:    baseURL,
          httpClient: retryClient,
          version:    version,
          logger:     logger,
      }
  }
  
  func (c *HTTPClient) CreateTask(ctx context.Context, req *models.CreateTaskRequest) (*models.TaskResponse, error) {
      body, err := json.Marshal(req)
      if err != nil {
          return nil, fmt.Errorf("failed to marshal request: %w", err)
      }
      
      httpReq, err := retryablehttp.NewRequestWithContext(ctx, "POST", 
          fmt.Sprintf("%s/api/v1/tasks", c.baseURL), bytes.NewReader(body))
      if err != nil {
          return nil, fmt.Errorf("failed to create request: %w", err)
      }
      
      c.setHeaders(httpReq)
      
      resp, err := c.httpClient.Do(httpReq)
      if err != nil {
          return nil, fmt.Errorf("request failed: %w", err)
      }
      defer resp.Body.Close()
      
      if resp.StatusCode != http.StatusCreated {
          return nil, c.handleErrorResponse(resp)
      }
      
      var taskResp models.TaskResponse
      if err := json.NewDecoder(resp.Body).Decode(&taskResp); err != nil {
          return nil, fmt.Errorf("failed to decode response: %w", err)
      }
      
      return &taskResp, nil
  }
  
  func (c *HTTPClient) setHeaders(req *retryablehttp.Request) {
      req.Header.Set("Content-Type", "application/json")
      req.Header.Set("X-Version", c.version)
      req.Header.Set("User-Agent", fmt.Sprintf("lmmc-cli/%s", c.version))
  }
  
  // WebSocket client
  package api
  
  type WebSocketClient struct {
      serverURL       string
      version         string
      conn            *websocket.Conn
      hub             *NotificationHub
      reconnectDelay  time.Duration
      maxReconnect    time.Duration
      done            chan struct{}
      logger          *slog.Logger
      subscribedRepos []string
      mu              sync.RWMutex
  }
  
  type NotificationHub interface {
      PublishTaskEvent(event *TaskEvent)
      PublishConnectionStatus(connected bool)
  }
  
  func NewWebSocketClient(serverURL, version string, hub NotificationHub, logger *slog.Logger) *WebSocketClient {
      // Convert HTTP URL to WebSocket URL
      wsURL := strings.Replace(serverURL, "http://", "ws://", 1)
      wsURL = strings.Replace(wsURL, "https://", "wss://", 1)
      
      return &WebSocketClient{
          serverURL:      wsURL,
          version:        version,
          hub:            hub,
          reconnectDelay: 1 * time.Second,
          maxReconnect:   60 * time.Second,
          done:           make(chan struct{}),
          logger:         logger,
      }
  }
  
  func (c *WebSocketClient) Connect(ctx context.Context) error {
      c.mu.Lock()
      defer c.mu.Unlock()
      
      if c.conn != nil {
          return nil // Already connected
      }
      
      headers := http.Header{}
      headers.Set("X-Version", c.version)
      
      dialer := websocket.Dialer{
          HandshakeTimeout: 10 * time.Second,
      }
      
      conn, _, err := dialer.DialContext(ctx, fmt.Sprintf("%s/ws", c.serverURL), headers)
      if err != nil {
          return fmt.Errorf("websocket dial failed: %w", err)
      }
      
      c.conn = conn
      c.hub.PublishConnectionStatus(true)
      
      // Start read pump
      go c.readPump()
      
      // Subscribe to repositories
      if len(c.subscribedRepos) > 0 {
          c.sendSubscribe()
      }
      
      c.logger.Info("websocket connected", slog.String("url", c.serverURL))
      return nil
  }
  
  func (c *WebSocketClient) SubscribeToRepositories(repos []string) error {
      c.mu.Lock()
      c.subscribedRepos = repos
      conn := c.conn
      c.mu.Unlock()
      
      if conn != nil {
          return c.sendSubscribe()
      }
      return nil
  }
  
  func (c *WebSocketClient) sendSubscribe() error {
      event := Event{
          Type:      EventTypeSubscribe,
          Timestamp: time.Now(),
          Data: SubscribeEvent{
              Repositories: c.subscribedRepos,
          },
      }
      
      c.mu.RLock()
      conn := c.conn
      c.mu.RUnlock()
      
      if conn == nil {
          return fmt.Errorf("not connected")
      }
      
      return conn.WriteJSON(event)
  }
  
  func (c *WebSocketClient) readPump() {
      defer func() {
          c.mu.Lock()
          if c.conn != nil {
              c.conn.Close()
              c.conn = nil
          }
          c.mu.Unlock()
          c.hub.PublishConnectionStatus(false)
          
          // Attempt reconnection
          go c.reconnectLoop()
      }()
      
      c.conn.SetReadLimit(maxMessageSize)
      c.conn.SetReadDeadline(time.Now().Add(pongWait))
      c.conn.SetPongHandler(func(string) error {
          c.conn.SetReadDeadline(time.Now().Add(pongWait))
          return nil
      })
      
      for {
          var event Event
          err := c.conn.ReadJSON(&event)
          if err != nil {
              if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                  c.logger.Error("websocket read error", slog.Any("error", err))
              }
              break
          }
          
          c.handleEvent(event)
      }
  }
  
  func (c *WebSocketClient) handleEvent(event Event) {
      switch event.Type {
      case EventTypeTaskCreated, EventTypeTaskUpdated, EventTypeTaskDeleted:
          if taskEvent, ok := event.Data.(*TaskEvent); ok {
              c.hub.PublishTaskEvent(taskEvent)
          }
          
      case EventTypePing:
          // Send pong
          c.mu.RLock()
          conn := c.conn
          c.mu.RUnlock()
          
          if conn != nil {
              pongEvent := Event{
                  Type:      EventTypePong,
                  Timestamp: time.Now(),
              }
              conn.WriteJSON(pongEvent)
          }
          
      case EventTypeError:
          c.logger.Error("server error event", slog.String("error", event.Error))
      }
  }
  
  // Sync manager
  package api
  
  type SyncManager struct {
      httpClient      *HTTPClient
      wsClient        *WebSocketClient
      localStorage    storage.TaskStorage
      notificationHub *NotificationHub
      conflictResolver ConflictResolver
      logger          *slog.Logger
      mu              sync.Mutex
  }
  
  type ConflictResolver interface {
      ResolveConflict(local, remote *types.Task) *types.Task
  }
  
  func NewSyncManager(httpClient *HTTPClient, wsClient *WebSocketClient, 
      localStorage storage.TaskStorage, logger *slog.Logger) *SyncManager {
      
      hub := NewNotificationHub(logger)
      
      manager := &SyncManager{
          httpClient:       httpClient,
          wsClient:         wsClient,
          localStorage:     localStorage,
          notificationHub:  hub,
          conflictResolver: NewServerTruthResolver(),
          logger:           logger,
      }
      
      // Start WebSocket connection
      go manager.maintainConnection()
      
      return manager
  }
  
  func (m *SyncManager) CreateTask(ctx context.Context, task *types.Task) error {
      // Try server first
      req := &models.CreateTaskRequest{
          Content:    task.Content,
          Priority:   task.Priority,
          Repository: task.Repository,
      }
      
      resp, err := m.httpClient.CreateTask(ctx, req)
      if err != nil {
          // Store locally and queue for retry
          m.logger.Warn("server create failed, storing locally", slog.Any("error", err))
          return m.localStorage.Create(ctx, task)
      }
      
      // Update local task with server response
      task.ID = resp.ID
      task.CreatedAt = resp.CreatedAt
      task.UpdatedAt = resp.UpdatedAt
      
      // Store locally
      return m.localStorage.Create(ctx, task)
  }
  
  // Notification service
  package services
  
  type NotificationService struct {
      eventChan chan TaskEvent
      statusChan chan bool
      output     io.Writer
      logger     *slog.Logger
  }
  
  func NewNotificationService(output io.Writer, logger *slog.Logger) *NotificationService {
      return &NotificationService{
          eventChan:  make(chan TaskEvent, 100),
          statusChan: make(chan bool, 10),
          output:     output,
          logger:     logger,
      }
  }
  
  func (n *NotificationService) Start(ctx context.Context) {
      for {
          select {
          case <-ctx.Done():
              return
              
          case event := <-n.eventChan:
              n.displayTaskEvent(event)
              
          case connected := <-n.statusChan:
              n.displayConnectionStatus(connected)
          }
      }
  }
  
  func (n *NotificationService) displayTaskEvent(event TaskEvent) {
      var message string
      
      switch event.Type {
      case EventTypeTaskCreated:
          message = fmt.Sprintf("ðŸ“ New task created: %s", event.Task.Content)
      case EventTypeTaskUpdated:
          message = fmt.Sprintf("âœï¸  Task updated: %s", event.Task.Content)
      case EventTypeTaskDeleted:
          message = fmt.Sprintf("ðŸ—‘ï¸  Task deleted: %s", event.TaskID)
      }
      
      if message != "" && event.ChangedBy != "cli" {
          fmt.Fprintf(n.output, "\n%s\n> ", message)
      }
  }
  
  func (n *NotificationService) displayConnectionStatus(connected bool) {
      if connected {
          fmt.Fprintf(n.output, "\nâœ… Connected to server\n> ")
      } else {
          fmt.Fprintf(n.output, "\nâš ï¸  Disconnected from server (working offline)\n> ")
      }
  }
  ```

- **Configuration Changes:** 
  - Add server URL configuration to CLI
  - Add WebSocket connection settings
  - Configure notification preferences

- **Dependencies:** Already included from previous sub-tasks

## 4. Acceptance Criteria
- **Functional Criteria:**
  - CLI connects to HTTP API for all task operations
  - WebSocket connection established for real-time updates
  - Push notifications display in REPL mode
  - Automatic reconnection after network interruption
  - Offline operations queue and sync when reconnected
  - Version compatibility enforced
  - Repository-based subscriptions work
  
- **Technical Criteria:**
  - HTTP client retries on transient failures
  - WebSocket reconnects with exponential backoff
  - Notifications don't interrupt user input
  - Memory usage stable with long connections
  - Concurrent operations handled safely
  
- **Integration Criteria:**
  - Works with existing local storage fallback
  - Integrates with all CLI commands
  - Conflict resolution favors server state
  
- **Test Criteria:**
  - Connection lifecycle properly managed
  - Notifications display correctly
  - Offline mode transitions smoothly
  - Sync conflicts resolved correctly

## 5. Testing Requirements
- **Unit Tests:**
  - HTTP client retry logic
  - WebSocket event handling
  - Notification formatting
  - Connection state management
  - Conflict resolution logic
  
- **Integration Tests:**
  - Full sync flow with server
  - WebSocket reconnection scenarios
  - Offline to online transitions
  - Concurrent operation handling
  - Version mismatch handling
  
- **Manual Testing:**
  - CLI commands with server running
  - Network interruption recovery
  - Real-time notification display
  - Multi-repository scenarios
  
- **Test Data:**
  - Various network conditions
  - Conflicting task states
  - Multiple repository setups

## 6. Definition of Done
- **Code Complete:** HTTP and WebSocket clients fully integrated
- **Tests Passing:** All sync scenarios tested (â‰¥85% coverage)
- **Documentation Updated:** Server connection setup documented
- **Integration Verified:** Real-time sync works end-to-end
- **Review Approved:** Network resilience and error handling reviewed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** All previous MT-003 sub-tasks
- **External Dependencies:** None (uses existing libraries)
- **Environmental Requirements:** Network access to server
- **Potential Blockers:** Firewall restrictions on WebSocket

## 8. Integration Notes
- **Component Interfaces:** Replaces direct MCP calls with HTTP/WebSocket
- **Data Flow:** CLI â†’ HTTP API â†’ Storage â†’ WebSocket â†’ CLI notifications
- **Error Handling:** Graceful degradation to offline mode
- **Configuration Impact:** Server URL and connection settings required