# ST-MT-002-004: Implement REPL Mode with HTTP Server for Interactive Document Generation

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-002-004
- **Sub-Task Name:** Implement REPL Mode with HTTP Server for Interactive Document Generation
- **Parent Task:** MT-002: AI-Powered Development Automation with Document Generation
- **Estimated Duration:** 5 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Interactive REPL mode for document generation with embedded HTTP server
- **Code Location:** 
  - `cli/internal/repl/` - REPL core functionality
  - `cli/internal/adapters/secondary/http/repl_server.go` - HTTP server
  - `cli/internal/repl/generators/` - Document generation commands
- **Technical Requirements:** HTTP server, WebSocket support, interactive terminal, session management, document generation
- **Interface Definition:** REPL interface with document generation commands and HTTP endpoints

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create REPL session manager and state handling
  2. Implement interactive terminal interface with input/output
  3. Add document generation commands (prd, trd, tasks, workflow)
  4. Create embedded HTTP server for push notifications
  5. Add WebSocket support for real-time communication
  6. Implement AI conversation handling and context
  7. Create interactive document generation flows
  8. Create session persistence and restoration
  9. Add command parsing and execution within REPL
  10. Implement graceful shutdown and cleanup

- **Code Examples:**
  ```go
  // REPL interface and implementation
  type REPL interface {
      Start(ctx context.Context) error
      Stop() error
      HandleCommand(command string) (string, error)
      SetAIService(ai AIService)
      SetTaskService(tasks TaskService)
  }
  
  type REPLSession struct {
      ID            string              `json:"id"`
      StartedAt     time.Time           `json:"started_at"`
      LastActivity  time.Time           `json:"last_activity"`
      Context       ConversationContext `json:"context"`
      History       []REPLExchange      `json:"history"`
      State         SessionState        `json:"state"`
  }
  
  type ConversationContext struct {
      CurrentPRD    *PRD            `json:"current_prd,omitempty"`
      WorkingTasks  []*Task         `json:"working_tasks"`
      Repository    string          `json:"repository"`
      UserGoals     []string        `json:"user_goals"`
      Preferences   UserPreferences `json:"preferences"`
  }
  
  type REPLExchange struct {
      Timestamp time.Time `json:"timestamp"`
      Type      string    `json:"type"`      // user, ai, system
      Content   string    `json:"content"`
      Metadata  map[string]interface{} `json:"metadata,omitempty"`
  }
  
  type SessionState string
  const (
      StateActive    SessionState = "active"
      StateIdle      SessionState = "idle"
      StatePaused    SessionState = "paused"
      StateTerminated SessionState = "terminated"
  )
  
  // Interactive REPL implementation
  type InteractiveREPL struct {
      session        *REPLSession
      aiService      AIService
      taskService    TaskService
      httpServer     *REPLHttpServer
      input          io.Reader
      output         io.Writer
      logger         *slog.Logger
      config         *REPLConfig
      commandHandler CommandHandler
      running        atomic.Bool
  }
  
  type REPLConfig struct {
      Port           int           `mapstructure:"port"`
      Host           string        `mapstructure:"host"`
      EnableHTTP     bool          `mapstructure:"enable_http"`
      EnableWebSocket bool         `mapstructure:"enable_websocket"`
      SessionTimeout time.Duration `mapstructure:"session_timeout"`
      HistoryLimit   int           `mapstructure:"history_limit"`
      AutoSave       bool          `mapstructure:"auto_save"`
  }
  
  func NewInteractiveREPL(config *REPLConfig, logger *slog.Logger) *InteractiveREPL {
      repl := &InteractiveREPL{
          session: &REPLSession{
              ID:        uuid.New().String(),
              StartedAt: time.Now(),
              Context:   ConversationContext{WorkingTasks: make([]*Task, 0)},
              History:   make([]REPLExchange, 0),
              State:     StateActive,
          },
          input:          os.Stdin,
          output:         os.Stdout,
          logger:         logger,
          config:         config,
          commandHandler: NewREPLCommandHandler(),
      }
      
      // Initialize HTTP server if enabled
      if config.EnableHTTP {
          repl.httpServer = NewREPLHttpServer(config, repl, logger)
      }
      
      return repl
  }
  
  func (r *InteractiveREPL) Start(ctx context.Context) error {
      r.running.Store(true)
      
      // Start HTTP server
      if r.httpServer != nil {
          if err := r.httpServer.Start(); err != nil {
              return fmt.Errorf("failed to start HTTP server: %w", err)
          }
          r.logger.Info("REPL HTTP server started",
              slog.String("url", r.httpServer.URL()))
      }
      
      // Print welcome message
      r.printWelcome()
      
      // Main REPL loop
      scanner := bufio.NewScanner(r.input)
      
      for r.running.Load() && scanner.Scan() {
          input := strings.TrimSpace(scanner.Text())
          
          if input == "" {
              continue
          }
          
          // Handle exit commands
          if input == "exit" || input == "quit" {
              break
          }
          
          // Process command
          response, err := r.HandleCommand(input)
          if err != nil {
              r.printError(err)
              continue
          }
          
          // Print response
          r.printResponse(response)
          
          // Update session activity
          r.session.LastActivity = time.Now()
      }
      
      return r.Stop()
  }
  
  func (r *InteractiveREPL) HandleCommand(command string) (string, error) {
      // Add to history
      r.addToHistory("user", command)
      
      // Parse command
      cmd, args, err := r.commandHandler.Parse(command)
      if err != nil {
          return "", fmt.Errorf("invalid command: %w", err)
      }
      
      // Execute command
      var response string
      
      switch cmd {
      case "ai", "ask":
          response, err = r.handleAIQuery(args)
      case "prd":
          response, err = r.handlePRDCommand(args)
      case "trd":
          response, err = r.handleTRDCommand(args)
      case "tasks":
          response, err = r.handleTasksCommand(args)
      case "generate":
          response, err = r.handleGenerateCommand(args)
      case "workflow":
          response, err = r.handleWorkflowCommand(args)
      case "rules":
          response, err = r.handleRulesCommand(args)
      case "help":
          response = r.getHelpMessage()
      case "status":
          response = r.getStatusMessage()
      case "clear":
          r.clearHistory()
          response = "History cleared"
      default:
          return "", fmt.Errorf("unknown command: %s", cmd)
      }
      
      if err != nil {
          return "", err
      }
      
      // Add response to history
      r.addToHistory("ai", response)
      
      return response, nil
  }
  
  func (r *InteractiveREPL) handleAIQuery(query string) (string, error) {
      if r.aiService == nil {
          return "", fmt.Errorf("AI service not available")
      }
      
      // Build context for AI query
      context := r.buildAIContext(query)
      
      // Send to AI service
      prompt := r.buildPrompt(query, context)
      
      // This would integrate with the AI service
      // For now, return a placeholder
      response := fmt.Sprintf("AI response to: %s", query)
      
      return response, nil
  }
  
  func (r *InteractiveREPL) handlePRDCommand(args string) (string, error) {
      parts := strings.Fields(args)
      if len(parts) == 0 {
          return "Usage: prd <create|import|view|status>", nil
      }
      
      action := parts[0]
      switch action {
      case "create":
          return r.startPRDCreation()
      case "import":
          if len(parts) < 2 {
              return "", fmt.Errorf("usage: prd import <file_path>")
          }
          return r.importPRD(parts[1])
      case "view":
          return r.viewCurrentPRD()
      case "status":
          return r.getPRDStatus()
      default:
          return "", fmt.Errorf("unknown prd action: %s", action)
      }
  }
  
  func (r *InteractiveREPL) startPRDCreation() (string, error) {
      // Start interactive PRD creation session
      session, err := r.aiService.StartInteractiveSession(DocumentTypePRD)
      if err != nil {
          return "", fmt.Errorf("failed to start PRD creation: %w", err)
      }
      
      r.session.Context.CurrentSession = session
      
      return "Starting interactive PRD creation. I'll ask you some questions to help create a comprehensive PRD.", nil
  }
  
  func (r *InteractiveREPL) handleTRDCommand(args string) (string, error) {
      parts := strings.Fields(args)
      if len(parts) == 0 {
          return "Usage: trd <create|view|status>", nil
      }
      
      action := parts[0]
      switch action {
      case "create":
          if r.session.Context.CurrentPRD == nil {
              return "", fmt.Errorf("no PRD available. Create or import a PRD first")
          }
          return r.generateTRD()
      case "view":
          return r.viewCurrentTRD()
      case "status":
          return r.getTRDStatus()
      default:
          return "", fmt.Errorf("unknown trd action: %s", action)
      }
  }
  
  func (r *InteractiveREPL) handleWorkflowCommand(args string) (string, error) {
      parts := strings.Fields(args)
      if len(parts) == 0 {
          return "Usage: workflow <run|status|stop>", nil
      }
      
      action := parts[0]
      switch action {
      case "run":
          return r.runCompleteWorkflow()
      case "status":
          return r.getWorkflowStatus()
      case "stop":
          return r.stopWorkflow()
      default:
          return "", fmt.Errorf("unknown workflow action: %s", action)
      }
  }
  
  func (r *InteractiveREPL) runCompleteWorkflow() (string, error) {
      // Execute complete document generation chain
      r.printProgress("Starting complete workflow: PRD ‚Üí TRD ‚Üí Main Tasks ‚Üí Sub-tasks")
      
      // This would integrate with the document chain
      go func() {
          // Simulate workflow execution with progress updates
          stages := []string{
              "Creating PRD interactively...",
              "Generating TRD from PRD...",
              "Creating main tasks from TRD...",
              "Generating sub-tasks for each main task...",
          }
          
          for _, stage := range stages {
              r.sendNotification("workflow", stage)
              time.Sleep(2 * time.Second) // Simulate processing
          }
          
          r.sendNotification("workflow", "Workflow completed successfully!")
      }()
      
      return "Workflow started. You'll receive progress notifications.", nil
  }
  
  func (r *InteractiveREPL) handleRulesCommand(args string) (string, error) {
      parts := strings.Fields(args)
      if len(parts) == 0 {
          return "Usage: rules <list|view|edit|set>", nil
      }
      
      action := parts[0]
      switch action {
      case "list":
          return r.listRules()
      case "view":
          if len(parts) < 2 {
              return "", fmt.Errorf("usage: rules view <rule_type>")
          }
          return r.viewRule(parts[1])
      case "edit":
          if len(parts) < 2 {
              return "", fmt.Errorf("usage: rules edit <rule_type>")
          }
          return r.editRule(parts[1])
      case "set":
          if len(parts) < 3 {
              return "", fmt.Errorf("usage: rules set <rule_type> <file_path>")
          }
          return r.setCustomRule(parts[1], parts[2])
      default:
          return "", fmt.Errorf("unknown rules action: %s", action)
      }
  }
  
  // HTTP server for push notifications
  type REPLHttpServer struct {
      server *http.Server
      repl   *InteractiveREPL
      logger *slog.Logger
      config *REPLConfig
  }
  
  func NewREPLHttpServer(config *REPLConfig, repl *InteractiveREPL, logger *slog.Logger) *REPLHttpServer {
      mux := http.NewServeMux()
      
      server := &REPLHttpServer{
          repl:   repl,
          logger: logger,
          config: config,
      }
      
      // Setup routes
      mux.HandleFunc("/health", server.handleHealth)
      mux.HandleFunc("/session", server.handleSession)
      mux.HandleFunc("/notify", server.handleNotification)
      
      if config.EnableWebSocket {
          mux.HandleFunc("/ws", server.handleWebSocket)
      }
      
      server.server = &http.Server{
          Addr:    fmt.Sprintf("%s:%d", config.Host, config.Port),
          Handler: mux,
      }
      
      return server
  }
  
  func (s *REPLHttpServer) Start() error {
      go func() {
          if err := s.server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
              s.logger.Error("HTTP server error", slog.Any("error", err))
          }
      }()
      
      return nil
  }
  
  func (s *REPLHttpServer) URL() string {
      return fmt.Sprintf("http://%s:%d", s.config.Host, s.config.Port)
  }
  
  func (s *REPLHttpServer) handleHealth(w http.ResponseWriter, r *http.Request) {
      response := map[string]interface{}{
          "status":    "healthy",
          "session":   s.repl.session.ID,
          "uptime":    time.Since(s.repl.session.StartedAt).String(),
          "state":     s.repl.session.State,
      }
      
      w.Header().Set("Content-Type", "application/json")
      json.NewEncoder(w).Encode(response)
  }
  
  func (s *REPLHttpServer) handleSession(w http.ResponseWriter, r *http.Request) {
      switch r.Method {
      case http.MethodGet:
          s.handleGetSession(w, r)
      case http.MethodPost:
          s.handleUpdateSession(w, r)
      default:
          http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
      }
  }
  
  func (s *REPLHttpServer) handleNotification(w http.ResponseWriter, r *http.Request) {
      if r.Method != http.MethodPost {
          http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
          return
      }
      
      var notification struct {
          Type    string      `json:"type"`
          Message string      `json:"message"`
          Data    interface{} `json:"data,omitempty"`
      }
      
      if err := json.NewDecoder(r.Body).Decode(&notification); err != nil {
          http.Error(w, "Invalid JSON", http.StatusBadRequest)
          return
      }
      
      // Display notification in REPL
      s.displayNotification(notification.Type, notification.Message)
      
      w.WriteHeader(http.StatusOK)
      json.NewEncoder(w).Encode(map[string]string{"status": "received"})
  }
  
  func (s *REPLHttpServer) displayNotification(notifType, message string) {
      // This would send the notification to the REPL display
      formatted := fmt.Sprintf("\nüîî [%s] %s\n> ", notifType, message)
      fmt.Fprint(s.repl.output, formatted)
  }
  
  // Command handler for REPL commands
  type CommandHandler interface {
      Parse(input string) (command string, args string, error error)
      GetCommands() []string
      GetHelp(command string) string
  }
  
  type DefaultCommandHandler struct {
      commands map[string]CommandInfo
  }
  
  type CommandInfo struct {
      Name        string   `json:"name"`
      Description string   `json:"description"`
      Usage       string   `json:"usage"`
      Examples    []string `json:"examples"`
  }
  
  func NewREPLCommandHandler() *DefaultCommandHandler {
      return &DefaultCommandHandler{
          commands: map[string]CommandInfo{
              "ai": {
                  Name:        "ai",
                  Description: "Ask AI assistant a question",
                  Usage:       "ai <question>",
                  Examples:    []string{"ai how do I implement authentication?", "ai what are the next steps?"},
              },
              "prd": {
                  Name:        "prd",
                  Description: "PRD operations (create, import, view, status)",
                  Usage:       "prd <action> [args]",
                  Examples:    []string{"prd create", "prd import /path/to/prd.md", "prd view", "prd status"},
              },
              "trd": {
                  Name:        "trd",
                  Description: "TRD operations (create from PRD, view, status)",
                  Usage:       "trd <action> [args]",
                  Examples:    []string{"trd create", "trd view", "trd status"},
              },
              "tasks": {
                  Name:        "tasks",
                  Description: "Task operations (generate-main, generate-sub, list, view)",
                  Usage:       "tasks <action> [args]",
                  Examples:    []string{"tasks generate-main", "tasks generate-sub MT-001", "tasks list", "tasks view MT-001"},
              },
              "workflow": {
                  Name:        "workflow",
                  Description: "Run complete document generation workflow",
                  Usage:       "workflow <action>",
                  Examples:    []string{"workflow run", "workflow status", "workflow stop"},
              },
              "rules": {
                  Name:        "rules",
                  Description: "Manage generation rules (list, view, edit, set)",
                  Usage:       "rules <action> [args]",
                  Examples:    []string{"rules list", "rules view prd", "rules edit trd", "rules set prd ./custom-prd.mdc"},
              },
              "generate": {
                  Name:        "generate",
                  Description: "Generate specific document types",
                  Usage:       "generate <type> [options]",
                  Examples:    []string{"generate prd", "generate trd", "generate main-tasks", "generate sub-tasks MT-001"},
              },
          },
      }
  }
  
  func (h *DefaultCommandHandler) Parse(input string) (string, string, error) {
      parts := strings.Fields(input)
      if len(parts) == 0 {
          return "", "", fmt.Errorf("empty command")
      }
      
      command := parts[0]
      args := ""
      
      if len(parts) > 1 {
          args = strings.Join(parts[1:], " ")
      }
      
      // Validate command exists
      if _, exists := h.commands[command]; !exists {
          return "", "", fmt.Errorf("unknown command: %s", command)
      }
      
      return command, args, nil
  }
  ```

- **Configuration Changes:** Adds REPL configuration with HTTP server settings
- **Dependencies:**
  - HTTP server and WebSocket libraries
  - Interactive terminal handling
  - Session persistence

## 4. Acceptance Criteria
- **Functional Criteria:**
  - REPL mode provides interactive document generation capabilities
  - Interactive PRD creation guides users through the process
  - TRD generation works from existing PRDs
  - Task generation creates main and sub-tasks interactively
  - Complete workflow automation runs end-to-end
  - Rule management allows viewing and customizing generation rules
  - HTTP server receives and displays push notifications
  - Session management preserves context across interactions
  - Command parsing handles all document generation commands correctly
  - WebSocket support enables real-time communication
  
- **Technical Criteria:**
  - Document generation integrates with AI service and rules
  - Interactive sessions maintain state correctly
  - HTTP server operates securely on localhost only
  - Session state persists and can be restored
  - Error handling provides helpful feedback
  - Performance is responsive for interactive use
  
- **Integration Criteria:**
  - REPL integrates with all document generation services
  - Commands work with document chain orchestration
  - Rule system integration allows customization
  - HTTP endpoints follow REST conventions
  - Command handlers support extensibility
  
- **Test Criteria:**
  - All document generation commands tested
  - Interactive PRD creation flow tested
  - Complete workflow execution tested
  - Rule management operations tested
  - HTTP server endpoints tested for security and functionality
  - Session management tested for persistence and cleanup

## 5. Testing Requirements
- **Unit Tests:**
  - REPL command parsing and execution
  - Document generation command handlers
  - Interactive session state management
  - Rule command processing
  - Workflow orchestration logic
  - Session state management and persistence
  - HTTP server endpoint handlers
  - WebSocket connection handling
  - Command handler validation and help system
  - Notification display and formatting
  - Error handling for invalid commands

- **Integration Tests:**
  - Complete PRD creation flow in REPL
  - TRD generation from existing PRD
  - Main and sub-task generation
  - Full workflow execution
  - Rule customization and application
  - HTTP server integration with notifications
  - Session persistence across REPL restarts
  - Document chain integration
  
- **Manual Testing:**
  - Interactive PRD creation experience
  - Document generation quality
  - Workflow progress tracking
  - Rule editing interface
  - Real-time notification display
  - Session context preservation
  - Cross-platform terminal compatibility
  
- **Test Data:** Document templates, rule files, workflow scenarios, session states

## 6. Definition of Done
- **Code Complete:** REPL mode with document generation and HTTP server fully implemented
- **Tests Passing:** All interactive and generation scenarios tested (‚â•85% coverage)
- **Documentation Updated:** All REPL commands, document generation flows, and HTTP API documented
- **Integration Verified:** Works with document chain, AI service, and rule system
- **Review Approved:** Security review for HTTP server, session handling, and AI prompts

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** 
  - ST-MT-002-002 (AI Service Layer)
  - ST-MT-002-003 (Document Chain and Task Generation)
  - ST-MT-002-001 (Document Entities and Rules)
- **External Dependencies:** HTTP libraries, terminal I/O handling, interactive prompts
- **Environmental Requirements:** Available port for HTTP server (default 8080)
- **Potential Blockers:** Port conflicts, terminal compatibility, interactive flow complexity

## 8. Integration Notes
- **Component Interfaces:** Integrates with document chain, AI service, rule manager, and CLI framework
- **Data Flow:** 
  - Commands: User Input ‚Üí Command Parser ‚Üí Document Chain ‚Üí AI Service ‚Üí Generated Documents
  - Notifications: Document Chain ‚Üí HTTP Server ‚Üí REPL Display
- **Error Handling:** Graceful error display with recovery suggestions and workflow resumption
- **Configuration Impact:** HTTP server port, REPL settings, and interactive session configuration

## 9. Current Implementation Status

**Status:** ‚ùå NOT STARTED

**What has been implemented:**
- ‚úÖ Basic REPL command structure exists in `/cli/internal/adapters/primary/cli/repl_command.go`
- ‚úÖ CLI command framework is set up with Cobra

**What is missing:**
- ‚ùå REPL session manager and state handling
- ‚ùå Interactive terminal interface with input/output
- ‚ùå Document generation commands (prd, trd, tasks, workflow)
- ‚ùå Embedded HTTP server for push notifications
- ‚ùå WebSocket support for real-time communication
- ‚ùå AI conversation handling and context
- ‚ùå Interactive document generation flows
- ‚ùå Session persistence and restoration
- ‚ùå Command parsing and execution within REPL
- ‚ùå HTTP server endpoints for notifications
- ‚ùå Complete REPL implementation with all document features

**Next steps:**
1. Implement REPL session manager with state handling
2. Create interactive terminal interface
3. Add document generation commands integration
4. Implement embedded HTTP server with notification support
5. Add WebSocket support for real-time updates
6. Integrate with AI service for interactive sessions
7. Add session persistence and restoration
8. Implement comprehensive command parsing

**Deviations from original plan:**
- Only basic command structure exists; no actual REPL implementation
- No HTTP server or WebSocket integration has been started
- Interactive document generation flows are not implemented
- The sophisticated REPL mode described in the plan does not exist
- Command stubs exist but return "not implemented" errors