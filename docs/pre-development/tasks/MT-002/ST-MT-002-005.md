# ST-MT-002-005: Implement CLI Commands for Document Generation and Automation

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-002-005
- **Sub-Task Name:** Implement CLI Commands for Document Generation and Automation
- **Parent Task:** MT-002: AI-Powered Development Automation with Document Generation
- **Estimated Duration:** 5 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** CLI commands for complete document generation workflow and automation
- **Code Location:** 
  - `cli/internal/adapters/primary/cli/commands/prd.go` - PRD commands
  - `cli/internal/adapters/primary/cli/commands/trd.go` - TRD commands
  - `cli/internal/adapters/primary/cli/commands/tasks.go` - Task generation commands
  - `cli/internal/adapters/primary/cli/commands/workflow.go` - Workflow automation
  - `cli/internal/adapters/primary/cli/commands/rules.go` - Rule management
- **Technical Requirements:** Cobra CLI commands, progress indicators, interactive prompts, workflow automation
- **Interface Definition:** Command handlers for complete document generation chain

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create PRD commands (create, import, view, status)
  2. Implement TRD commands (create from PRD, view, export)
  3. Create task generation commands (generate-main, generate-sub)
  4. Implement workflow automation command (run complete chain)
  5. Add rule management commands (list, view, edit, set)
  6. Implement interactive prompts for document creation
  7. Add progress indicators for long-running operations
  8. Create output formatting for different formats (table, JSON, Markdown)
  9. Implement workflow state persistence and resumption
  10. Add comprehensive help and examples for all commands

- **Code Examples:**
  ```go
  // PRD command group and subcommands
  func NewPRDCommand(container *Container) *cobra.Command {
      cmd := &cobra.Command{
          Use:   "prd",
          Short: "PRD operations for development automation",
          Long: `Create, import, and manage Product Requirements Documents.
  
  The prd command provides AI-powered PRD creation and management as part of
  the complete development automation workflow.`,
          Example: `  # Create a new PRD interactively
    lmmc prd create
  
    # Import an existing PRD document
    lmmc prd import ./requirements.md
  
    # View current PRD
    lmmc prd view
  
    # List all PRDs
    lmmc prd list`,
      }
      
      // Add subcommands
      cmd.AddCommand(
          newPRDCreateCommand(container),
          newPRDImportCommand(container),
          newPRDViewCommand(container),
          newPRDListCommand(container),
          newPRDStatusCommand(container),
          newPRDExportCommand(container),
      )
      
      return cmd
  }
  
  // PRD create command for interactive generation
  func newPRDCreateCommand(container *Container) *cobra.Command {
      var interactive bool
      var template string
      
      cmd := &cobra.Command{
          Use:   "create",
          Short: "Create a new PRD interactively with AI",
          Long: `Create a Product Requirements Document through an interactive AI session.
  
  The AI will ask clarifying questions to help you create a comprehensive PRD
  following best practices and your organization's standards.`,
          Example: `  # Start interactive PRD creation
    lmmc prd create
  
    # Create PRD with a specific template
    lmmc prd create --template startup
  
    # Create PRD non-interactively (using defaults)
    lmmc prd create --no-interactive`,
          RunE: func(cmd *cobra.Command, args []string) error {
              return runPRDCreate(container, interactive, template)
          },
      }
      
      cmd.Flags().BoolVar(&interactive, "interactive", true, "Interactive mode for PRD creation")
      cmd.Flags().StringVar(&template, "template", "", "PRD template to use (startup, enterprise, mvp)")
      
      return cmd
  }
  
  func runPRDCreate(container *Container, interactive bool, template string) error {
      fmt.Printf("üöÄ Starting PRD Creation\\n")
      fmt.Printf("======================\\n\\n")
      
      if !interactive {
          return fmt.Errorf("non-interactive mode not yet implemented")
      }
      
      // Start interactive session
      session, err := container.AIService.StartInteractiveSession(DocumentTypePRD)
      if err != nil {
          return fmt.Errorf("failed to start PRD creation session: %w", err)
      }
      
      fmt.Printf("I'll help you create a comprehensive PRD. Let me ask you some questions.\\n\\n")
      
      // Interactive Q&A loop
      scanner := bufio.NewScanner(os.Stdin)
      
      for session.State == SessionStateActive {
          // Get next question from AI
          response, err := container.AIService.ContinueSession(session.ID, "")
          if err != nil {
              return fmt.Errorf("session error: %w", err)
          }
          
          // Display AI question
          fmt.Printf("ü§ñ %s\\n> ", response.Content)
          
          // Get user input
          if !scanner.Scan() {
              break
          }
          
          userInput := scanner.Text()
          
          // Send response to AI
          _, err = container.AIService.ContinueSession(session.ID, userInput)
          if err != nil {
              return fmt.Errorf("failed to process response: %w", err)
          }
      }
      
      // Generate final PRD
      prd, err := container.DocumentGenerator.GeneratePRD(session.Context)
      if err != nil {
          return fmt.Errorf("failed to generate PRD: %w", err)
      }
      
      // Save PRD
      if err := container.DocumentStore.Save(prd); err != nil {
          return fmt.Errorf("failed to save PRD: %w", err)
      }
      
      fmt.Printf("\\n‚úÖ PRD created successfully!\\n")
      fmt.Printf("   ID: %s\\n", prd.ID)
      fmt.Printf("   Name: %s\\n", prd.Name)
      fmt.Printf("\\nüí° Next step: Generate TRD with 'lmmc trd create'\\n")
      
      return nil
  }
  
  // PRD import command
  func newPRDImportCommand(container *Container) *cobra.Command {
      var force bool
      var name string
      
      cmd := &cobra.Command{
          Use:   "import <file>",
          Short: "Import a PRD document for processing",
          Long: `Import a Product Requirements Document from a file.
  
  Supports Markdown (.md) and plain text (.txt) files. The document will be
  analyzed for metadata and prepared for AI processing.`,
          Args: cobra.ExactArgs(1),
          Example: `  # Import a PRD document
    lmmc prd import ./requirements.md
  
    # Import with custom name
    lmmc prd import ./doc.txt --name "User Authentication PRD"
  
    # Force reimport of existing PRD
    lmmc prd import ./requirements.md --force`,
          RunE: func(cmd *cobra.Command, args []string) error {
              return runPRDImport(container, args[0], name, force)
          },
      }
      
      cmd.Flags().BoolVarP(&force, "force", "f", false, "Force reimport if PRD already exists")
      cmd.Flags().StringVarP(&name, "name", "n", "", "Custom name for the PRD")
      
      return cmd
  }
  
  func runPRDImport(container *Container, filePath, name string, force bool) error {
      logger := container.Logger.With(slog.String("command", "prd.import"))
      
      // Validate file path
      if !filepath.IsAbs(filePath) {
          wd, _ := os.Getwd()
          filePath = filepath.Join(wd, filePath)
      }
      
      // Check if file exists
      if _, err := os.Stat(filePath); os.IsNotExist(err) {
          return fmt.Errorf("file does not exist: %s", filePath)
      }
      
      logger.Info("importing PRD document", slog.String("file", filePath))
      
      // Show progress
      fmt.Printf("üìÑ Importing PRD document: %s\\n", filepath.Base(filePath))
      
      // Process file using file processor
      fileProcessor := container.FileProcessor
      prd, err := fileProcessor.ProcessFile(filePath)
      if err != nil {
          return fmt.Errorf("failed to process PRD file: %w", err)
      }
      
      // Set custom name if provided
      if name != "" {
          prd.Name = name
      }
      
      // Detect repository
      if repo, err := container.RepositoryDetector.DetectCurrent(); err == nil {
          prd.Repository = repo
      }
      
      // Check if PRD already exists
      existing, err := container.PRDService.GetByFile(filePath)
      if err == nil && existing != nil && !force {
          return fmt.Errorf("PRD already imported (use --force to reimport): %s", existing.Name)
      }
      
      // Save PRD
      if err := container.PRDService.Save(prd); err != nil {
          return fmt.Errorf("failed to save PRD: %w", err)
      }
      
      // Display results
      fmt.Printf("‚úÖ PRD imported successfully\\n")
      fmt.Printf("   ID: %s\\n", prd.ID)
      fmt.Printf("   Name: %s\\n", prd.Name)
      fmt.Printf("   Format: %s\\n", prd.Format)
      fmt.Printf("   Word Count: %d\\n", prd.Metadata.WordCount)
      fmt.Printf("   Sections: %d\\n", prd.Metadata.SectionCount)
      fmt.Printf("   Complexity: %s\\n", prd.Metadata.EstimatedComplexity)
      
      fmt.Printf("\\nüí° Next steps:\\n")
      fmt.Printf("   - Run 'lmmc prd analyze' to process with AI\\n")
      fmt.Printf("   - Run 'lmmc prd generate' to create tasks\\n")
      
      return nil
  }
  
  // PRD generate command
  func newPRDGenerateCommand(container *Container) *cobra.Command {
      var review bool
      var maxTasks int
      var complexity string
      var output string
      
      cmd := &cobra.Command{
          Use:   "generate [prd-id]",
          Short: "Generate tasks from PRD using AI",
          Long: `Generate development tasks from a PRD using AI analysis.
  
  This command uses AI to analyze the PRD content and create structured tasks
  with effort estimates, priorities, and dependencies.`,
          Args: cobra.MaximumNArgs(1),
          Example: `  # Generate tasks from current PRD
    lmmc prd generate
  
    # Generate with review before creating tasks
    lmmc prd generate --review
  
    # Limit number of generated tasks
    lmmc prd generate --max-tasks 20
  
    # Generate only high complexity tasks
    lmmc prd generate --complexity high`,
          RunE: func(cmd *cobra.Command, args []string) error {
              var prdID string
              if len(args) > 0 {
                  prdID = args[0]
              }
              return runPRDGenerate(container, prdID, review, maxTasks, complexity, output)
          },
      }
      
      cmd.Flags().BoolVarP(&review, "review", "r", false, "Review tasks before creating them")
      cmd.Flags().IntVar(&maxTasks, "max-tasks", 50, "Maximum number of tasks to generate")
      cmd.Flags().StringVar(&complexity, "complexity", "", "Filter by complexity (low, medium, high)")
      cmd.Flags().StringVarP(&output, "output", "o", "table", "Output format (table, json)")
      
      return cmd
  }
  
  func runPRDGenerate(container *Container, prdID string, review bool, maxTasks int, complexity, output string) error {
      logger := container.Logger.With(slog.String("command", "prd.generate"))
      
      // Get PRD
      var prd *PRD
      var err error
      
      if prdID != "" {
          prd, err = container.PRDService.GetByID(prdID)
      } else {
          prd, err = container.PRDService.GetCurrent()
      }
      
      if err != nil {
          return fmt.Errorf("failed to get PRD: %w", err)
      }
      
      if prd == nil {
          return fmt.Errorf("no PRD found (use 'lmmc prd import' first)")
      }
      
      fmt.Printf("ü§ñ Generating tasks from PRD: %s\\n", prd.Name)
      
      // Check if PRD is analyzed
      analysis, err := container.AIService.GetAnalysis(prd.ID)
      if err != nil || analysis == nil {
          fmt.Printf("üìä PRD not yet analyzed, running AI analysis...\\n")
          
          // Run analysis first
          analysis, err = container.AIService.ParsePRD(prd)
          if err != nil {
              return fmt.Errorf("failed to analyze PRD: %w", err)
          }
          
          fmt.Printf("‚úÖ PRD analysis complete\\n")
      }
      
      // Generate tasks
      fmt.Printf("‚öôÔ∏è  Generating tasks...\\n")
      
      context := GenerationContext{
          Repository:  prd.Repository,
          ProjectType: inferProjectType(prd),
          Templates:   container.TaskGenerator.GetTemplates(),
      }
      
      tasks, err := container.TaskGenerator.GenerateFromAnalysis(analysis, context)
      if err != nil {
          return fmt.Errorf("failed to generate tasks: %w", err)
      }
      
      // Filter by complexity if specified
      if complexity != "" {
          tasks = filterTasksByComplexity(tasks, complexity)
      }
      
      // Limit tasks if specified
      if len(tasks) > maxTasks {
          tasks = tasks[:maxTasks]
      }
      
      fmt.Printf("‚úÖ Generated %d tasks\\n\\n", len(tasks))
      
      // Review mode
      if review {
          approved, err := reviewGeneratedTasks(tasks)
          if err != nil {
              return fmt.Errorf("task review failed: %w", err)
          }
          tasks = approved
      }
      
      // Create tasks
      if len(tasks) > 0 {
          fmt.Printf("üíæ Creating %d tasks...\\n", len(tasks))
          
          for _, task := range tasks {
              if err := container.TaskService.CreateTask(context.Background(), task); err != nil {
                  logger.Warn("failed to create task",
                      slog.String("content", task.Content),
                      slog.Any("error", err))
                  continue
              }
          }
          
          fmt.Printf("‚úÖ Tasks created successfully\\n")
      }
      
      // Display results
      displayGeneratedTasks(tasks, output)
      
      return nil
  }
  
  func reviewGeneratedTasks(tasks []*Task) ([]*Task, error) {
      fmt.Printf("üìã Review Generated Tasks\\n")
      fmt.Printf("========================\\n\\n")
      
      var approved []*Task
      
      for i, task := range tasks {
          fmt.Printf("Task %d/%d:\\n", i+1, len(tasks))
          fmt.Printf("  Title: %s\\n", task.Content)
          fmt.Printf("  Priority: %s\\n", task.Priority)
          fmt.Printf("  Estimated Hours: %d\\n", task.EstimatedHours)
          if len(task.Tags) > 0 {
              fmt.Printf("  Tags: %s\\n", strings.Join(task.Tags, ", "))
          }
          fmt.Printf("\\n")
          
          // Prompt for approval
          for {
              fmt.Printf("Approve this task? [y/n/e/q] (y=yes, n=no, e=edit, q=quit): ")
              
              var response string
              fmt.Scanln(&response)
              response = strings.ToLower(strings.TrimSpace(response))
              
              switch response {
              case "y", "yes":
                  approved = append(approved, task)
                  goto nextTask
              case "n", "no":
                  goto nextTask
              case "e", "edit":
                  editedTask, err := editTask(task)
                  if err != nil {
                      fmt.Printf("Edit failed: %v\\n", err)
                      continue
                  }
                  approved = append(approved, editedTask)
                  goto nextTask
              case "q", "quit":
                  fmt.Printf("\\nReview cancelled.\\n")
                  return approved, nil
              default:
                  fmt.Printf("Invalid input. Please enter y, n, e, or q.\\n")
              }
          }
          
      nextTask:
          fmt.Printf("\\n")
      }
      
      fmt.Printf("Review complete. Approved %d out of %d tasks.\\n\\n", len(approved), len(tasks))
      return approved, nil
  }
  
  func displayGeneratedTasks(tasks []*Task, format string) {
      switch format {
      case "json":
          data, _ := json.MarshalIndent(tasks, "", "  ")
          fmt.Println(string(data))
      case "table":
      default:
          // Display as table
          fmt.Printf("Generated Tasks:\\n")
          fmt.Printf("================\\n\\n")
          
          for i, task := range tasks {
              fmt.Printf("%d. %s\\n", i+1, task.Content)
              fmt.Printf("   Priority: %s | Hours: %d", task.Priority, task.EstimatedHours)
              if len(task.Tags) > 0 {
                  fmt.Printf(" | Tags: %s", strings.Join(task.Tags, ", "))
              }
              fmt.Printf("\\n\\n")
          }
      }
  }
  
  // TRD command group
  func NewTRDCommand(container *Container) *cobra.Command {
      cmd := &cobra.Command{
          Use:   "trd",
          Short: "TRD operations for technical specifications",
          Long: `Generate and manage Technical Requirements Documents from PRDs.
  
  The trd command creates technical specifications automatically from existing
  PRDs as part of the development automation workflow.`,
          Example: `  # Generate TRD from current PRD
    lmmc trd create
  
    # Generate TRD from specific PRD
    lmmc trd create --prd-id <id>
  
    # View current TRD
    lmmc trd view`,
      }
      
      cmd.AddCommand(
          newTRDCreateCommand(container),
          newTRDViewCommand(container),
          newTRDExportCommand(container),
      )
      
      return cmd
  }
  
  // Tasks command group
  func NewTasksCommand(container *Container) *cobra.Command {
      cmd := &cobra.Command{
          Use:   "tasks",
          Short: "Task generation and management",
          Long: `Generate main tasks and sub-tasks from TRDs.
  
  The tasks command creates atomic, implementable tasks from technical
  requirements as part of the development automation workflow.`,
          Example: `  # Generate main tasks from current TRD
    lmmc tasks generate-main
  
    # Generate sub-tasks for a main task
    lmmc tasks generate-sub MT-001
  
    # List all generated tasks
    lmmc tasks list`,
      }
      
      cmd.AddCommand(
          newTasksGenerateMainCommand(container),
          newTasksGenerateSubCommand(container),
          newTasksListCommand(container),
      )
      
      return cmd
  }
  
  // Workflow command for complete automation
  func NewWorkflowCommand(container *Container) *cobra.Command {
      cmd := &cobra.Command{
          Use:   "workflow",
          Short: "Run complete development automation workflow",
          Long: `Execute the complete document generation chain from PRD to sub-tasks.
  
  The workflow command automates the entire development planning process:
  PRD ‚Üí TRD ‚Üí Main Tasks ‚Üí Sub-tasks`,
          Example: `  # Run complete workflow
    lmmc workflow run
  
    # Run workflow with specific PRD
    lmmc workflow run --prd-id <id>
  
    # Check workflow status
    lmmc workflow status`,
          RunE: func(cmd *cobra.Command, args []string) error {
              return runWorkflow(container)
          },
      }
      
      return cmd
  }
  
  func runWorkflow(container *Container) error {
      fmt.Printf("üîÑ Starting Complete Development Workflow\\n")
      fmt.Printf("=====================================\\n\\n")
      
      // Execute document chain
      result, err := container.DocumentChain.ExecuteFullChain("")
      if err != nil {
          return fmt.Errorf("workflow execution failed: %w", err)
      }
      
      // Display progress as workflow executes
      fmt.Printf("‚úÖ Workflow completed successfully!\\n\\n")
      
      fmt.Printf("üìä Results:\\n")
      fmt.Printf("   PRD: %s\\n", result.PRD.Name)
      fmt.Printf("   TRD: Generated\\n")
      fmt.Printf("   Main Tasks: %d\\n", len(result.MainTasks))
      fmt.Printf("   Sub-tasks: %d\\n", len(result.SubTasks))
      fmt.Printf("\\n")
      
      fmt.Printf("üìÅ Documents saved to: ./docs/generated/\\n")
      
      return nil
  }
  
  // Rules command group
  func NewRulesCommand(container *Container) *cobra.Command {
      cmd := &cobra.Command{
          Use:   "rules",
          Short: "Manage document generation rules",
          Long: `View and customize the rules used for document generation.
  
  Rules define how PRDs, TRDs, and tasks are generated. You can view default
  rules and provide custom rules to match your organization's standards.`,
          Example: `  # List all available rules
    lmmc rules list
  
    # View a specific rule
    lmmc rules view prd
  
    # Set a custom rule
    lmmc rules set prd ./my-prd-rule.mdc`,
      }
      
      cmd.AddCommand(
          newRulesListCommand(container),
          newRulesViewCommand(container),
          newRulesSetCommand(container),
      )
      
      return cmd
  }
  
  // REPL command integration
  func newREPLCommand(container *Container) *cobra.Command {
      cmd := &cobra.Command{
          Use:   "repl",
          Short: "Start interactive REPL mode",
          Long: `Start an interactive Read-Eval-Print Loop for AI-powered task management.
  
  REPL mode provides an interactive session where you can chat with AI,
  import PRDs, generate tasks, and manage your workflow conversationally.`,
          Example: `  # Start REPL mode
    lmmc repl
  
    # Start REPL with HTTP server enabled
    lmmc repl --http`,
          RunE: func(cmd *cobra.Command, args []string) error {
              return runREPL(container)
          },
      }
      
      return cmd
  }
  
  func runREPL(container *Container) error {
      logger := container.Logger.With(slog.String("command", "repl"))
      
      // Create REPL instance
      repl := container.REPL
      if repl == nil {
          return fmt.Errorf("REPL not available")
      }
      
      // Set services
      repl.SetAIService(container.AIService)
      repl.SetTaskService(container.TaskService)
      
      logger.Info("starting REPL mode")
      
      // Start REPL
      ctx := context.Background()
      return repl.Start(ctx)
  }
  ```

- **Configuration Changes:** None required (uses existing CLI configuration)
- **Dependencies:**
  - Cobra CLI framework
  - Interactive terminal input/output
  - Progress indicators and formatting

## 4. Acceptance Criteria
- **Functional Criteria:**
  - PRD create command provides interactive AI-guided creation
  - PRD import command validates files and extracts metadata
  - TRD create command generates technical specs from PRDs
  - Task generation commands create main and sub-tasks
  - Workflow command executes complete automation chain
  - Rules commands allow viewing and customizing generation rules
  - REPL command provides interactive document generation
  - Commands provide helpful progress indicators and feedback
  - Workflow state can be persisted and resumed
  
- **Technical Criteria:**
  - All commands follow CLI conventions and patterns
  - Interactive prompts guide users through document creation
  - Progress indicators show long-running operation status
  - Error handling provides clear, actionable messages
  - Help text and examples guide users effectively
  - Output formatting supports multiple formats (table, JSON, Markdown)
  
- **Integration Criteria:**
  - Commands integrate with document chain and AI services
  - Rule management integrates with generation engine
  - All commands work together in the automation workflow
  - REPL mode provides access to all document generation features
  
- **Test Criteria:**
  - Complete workflow tested end-to-end
  - All command scenarios tested with various inputs
  - Interactive flows tested with mock user input
  - Rule customization tested with sample rules
  - Error handling tested for edge cases

## 5. Testing Requirements
- **Unit Tests:**
  - Command argument parsing and validation
  - Interactive prompt flow for PRD creation
  - Document generation command logic
  - Workflow orchestration steps
  - Rule management operations
  - File path resolution and validation
  - Output formatting for different formats
  - Error handling for invalid inputs
  - Progress indicator display logic
  - Help text generation and accuracy

- **Integration Tests:**
  - Complete workflow execution (PRD ‚Üí Sub-tasks)
  - Interactive PRD creation flow
  - TRD generation from PRD
  - Task generation commands
  - Rule customization and application
  - Command integration with document chain
  - REPL mode with all document features
  - Workflow state persistence and resumption
  
- **Manual Testing:**
  - Complete automation workflow user experience
  - Interactive PRD creation quality
  - Rule customization workflow
  - Progress tracking during long operations
  - Error recovery and helpful messages
  - Cross-platform command compatibility
  
- **Test Data:** Sample documents, rule templates, workflow scenarios, interaction scripts

## 6. Definition of Done
- **Code Complete:** All document generation and workflow commands fully implemented
- **Tests Passing:** All command and workflow scenarios tested (‚â•85% coverage)
- **Documentation Updated:** Command help text, examples, and workflow guides complete
- **Integration Verified:** Works with document chain, AI services, and rule system
- **Review Approved:** User experience, CLI conventions, and workflow automation review

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** All previous MT-002 sub-tasks (document entities, AI service, document chain, REPL)
- **External Dependencies:** Cobra CLI framework, terminal I/O libraries, progress indicators
- **Environmental Requirements:** Terminal with interactive input support
- **Potential Blockers:** Terminal compatibility, complex workflow orchestration, interactive UX design

## 8. Integration Notes
- **Component Interfaces:** Integrates all MT-002 components through unified CLI interface
- **Data Flow:** 
  - Document Generation: Commands ‚Üí Document Chain ‚Üí AI Service ‚Üí Generated Documents
  - Workflow: Commands ‚Üí Workflow Orchestrator ‚Üí Step-by-Step Execution ‚Üí Complete Results
- **Error Handling:** User-friendly error messages with recovery suggestions and workflow resumption
- **Configuration Impact:** Uses CLI configuration for defaults, rule paths, and output preferences