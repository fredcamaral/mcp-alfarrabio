# ST-MT-004-006: Integration Tests for Intelligence Features

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-004-006
- **Sub-Task Name:** Integration Tests for Intelligence Features
- **Parent Task:** MT-004: Intelligence Features and Pattern Learning
- **Estimated Duration:** 3 hours
- **Implementation Type:** Testing

## 2. Deliverable Specification
- **Primary Output:** Comprehensive integration test suite for all MT-004 intelligence features
- **Code Location:** 
  - `cli/tests/integration/intelligence/pattern_detection_test.go`
  - `cli/tests/integration/intelligence/suggestion_test.go`
  - `cli/tests/integration/intelligence/template_test.go`
  - `cli/tests/integration/intelligence/cross_repo_test.go`
  - `cli/tests/integration/intelligence/analytics_test.go`
  - `cli/tests/e2e/intelligence_workflow_test.go`
- **Technical Requirements:** Integration testing, test data generation, performance validation
- **Interface Definition:** Test suites covering all intelligence features end-to-end

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create test infrastructure for intelligence features
  2. Generate comprehensive test data sets
  3. Implement pattern detection integration tests
  4. Create suggestion service integration tests
  5. Add template system integration tests
  6. Implement cross-repository learning tests
  7. Create analytics integration tests
  8. Add end-to-end workflow tests
  9. Implement performance benchmarks
  10. Create test utilities and helpers

- **Code Examples:**
  ```go
  // Test infrastructure
  package integration
  
  type IntelligenceTestSuite struct {
      suite.Suite
      taskStore        storage.TaskStorage
      patternStore     storage.PatternStorage
      templateStore    storage.TemplateStorage
      analyticsService services.AnalyticsService
      suggestionService services.SuggestionService
      testData         *TestDataGenerator
      cleanup          []func()
  }
  
  func (s *IntelligenceTestSuite) SetupSuite() {
      // Initialize test storage
      s.taskStore = storage.NewInMemoryTaskStorage()
      s.patternStore = storage.NewInMemoryPatternStorage()
      s.templateStore = storage.NewInMemoryTemplateStorage()
      
      // Initialize services
      patternDetector := services.NewPatternDetector(
          s.taskStore, s.patternStore, nil, slog.Default())
      
      s.suggestionService = services.NewSuggestionService(services.SuggestionDeps{
          ContextAnalyzer: services.NewContextAnalyzer(s.taskStore),
          PatternDetector: patternDetector,
          TaskStore:       s.taskStore,
          Logger:          slog.Default(),
      })
      
      s.analyticsService = services.NewAnalyticsService(services.AnalyticsDeps{
          TaskStore:    s.taskStore,
          PatternStore: s.patternStore,
          Logger:       slog.Default(),
      })
      
      // Initialize test data generator
      s.testData = NewTestDataGenerator()
  }
  
  func (s *IntelligenceTestSuite) TearDownSuite() {
      for _, cleanup := range s.cleanup {
          cleanup()
      }
  }
  
  // Pattern detection tests
  func (s *IntelligenceTestSuite) TestPatternDetectionAccuracy() {
      // Generate task sequences with known patterns
      tasks := s.testData.GeneratePatternedTasks(
          "test-repo",
          []PatternTemplate{
              {
                  Name:     "feature-development",
                  Sequence: []string{"design", "implement", "test", "document"},
                  Count:    10,
              },
              {
                  Name:     "bug-fix",
                  Sequence: []string{"investigate", "fix", "test"},
                  Count:    15,
              },
          },
      )
      
      // Store tasks
      ctx := context.Background()
      for _, task := range tasks {
          err := s.taskStore.Create(ctx, task)
          s.Require().NoError(err)
      }
      
      // Detect patterns
      detector := services.NewPatternDetector(
          s.taskStore, s.patternStore, nil, slog.Default())
      
      patterns, err := detector.DetectSequencePatterns(ctx, tasks, 0.1)
      s.Require().NoError(err)
      
      // Verify patterns detected
      s.Assert().GreaterOrEqual(len(patterns), 2, "Should detect at least 2 patterns")
      
      // Check pattern accuracy
      featurePattern := s.findPattern(patterns, "design", "implement", "test", "document")
      s.Assert().NotNil(featurePattern, "Should detect feature development pattern")
      s.Assert().Greater(featurePattern.Confidence, 0.8, "Pattern confidence should be high")
      s.Assert().Equal(10, featurePattern.Occurrences, "Should match occurrence count")
      
      bugFixPattern := s.findPattern(patterns, "investigate", "fix", "test")
      s.Assert().NotNil(bugFixPattern, "Should detect bug fix pattern")
      s.Assert().Greater(bugFixPattern.Confidence, 0.8, "Pattern confidence should be high")
  }
  
  func (s *IntelligenceTestSuite) TestPatternDetectionPerformance() {
      // Generate large dataset
      tasks := s.testData.GenerateRandomTasks("perf-repo", 10000)
      
      ctx := context.Background()
      for _, task := range tasks {
          s.taskStore.Create(ctx, task)
      }
      
      detector := services.NewPatternDetector(
          s.taskStore, s.patternStore, nil, slog.Default())
      
      // Measure performance
      start := time.Now()
      patterns, err := detector.DetectSequencePatterns(ctx, tasks, 0.01)
      duration := time.Since(start)
      
      s.Require().NoError(err)
      s.Assert().Less(duration, 5*time.Second, "Pattern detection should complete within 5 seconds")
      s.T().Logf("Detected %d patterns from %d tasks in %v", len(patterns), len(tasks), duration)
  }
  
  // Suggestion service tests
  func (s *IntelligenceTestSuite) TestSuggestionRelevance() {
      ctx := context.Background()
      
      // Setup context with current tasks
      currentTasks := []*entities.Task{
          s.testData.CreateTask("Setup authentication system", "high", "in_progress"),
          s.testData.CreateTask("Create user model", "high", "completed"),
      }
      
      for _, task := range currentTasks {
          s.taskStore.Create(ctx, task)
      }
      
      // Generate suggestions
      suggestions, err := s.suggestionService.GenerateSuggestions(ctx, "test-repo")
      s.Require().NoError(err)
      s.Assert().NotEmpty(suggestions, "Should generate suggestions")
      
      // Verify relevance
      relevantSuggestions := 0
      authRelated := []string{"auth", "security", "permission", "role", "token"}
      
      for _, suggestion := range suggestions {
          // Check if suggestion is related to authentication
          content := strings.ToLower(suggestion.Content)
          for _, keyword := range authRelated {
              if strings.Contains(content, keyword) {
                  relevantSuggestions++
                  break
              }
          }
      }
      
      relevanceRate := float64(relevantSuggestions) / float64(len(suggestions))
      s.Assert().Greater(relevanceRate, 0.5, "At least 50% of suggestions should be relevant")
  }
  
  func (s *IntelligenceTestSuite) TestSuggestionWithPatterns() {
      ctx := context.Background()
      
      // Create historical pattern
      pattern := &entities.TaskPattern{
          ID:   uuid.New().String(),
          Type: entities.PatternTypeSequence,
          Name: "API Development",
          Sequence: []entities.PatternStep{
              {Order: 1, TaskType: "design", Keywords: []string{"api", "endpoint"}},
              {Order: 2, TaskType: "implement", Keywords: []string{"controller", "route"}},
              {Order: 3, TaskType: "test", Keywords: []string{"integration", "api"}},
          },
          Confidence:  0.9,
          SuccessRate: 0.95,
          Repository:  "test-repo",
      }
      
      s.patternStore.Create(ctx, pattern)
      
      // Current task matches pattern step 1
      currentTask := s.testData.CreateTask("Design user API endpoints", "high", "completed")
      currentTask.Metadata["keywords"] = []string{"api", "endpoint", "design"}
      s.taskStore.Create(ctx, currentTask)
      
      // Get next task suggestion
      suggestion, err := s.suggestionService.GetNextTaskSuggestion(ctx, currentTask)
      s.Require().NoError(err)
      s.Assert().NotNil(suggestion)
      
      // Should suggest implementation step
      s.Assert().Contains(strings.ToLower(suggestion.Content), "implement")
      s.Assert().Equal("pattern", suggestion.Source.Type)
      s.Assert().Greater(suggestion.Confidence, 0.8)
  }
  
  // Template system tests
  func (s *IntelligenceTestSuite) TestProjectTypeDetection() {
      classifier := services.NewProjectClassifier(nil, slog.Default())
      
      testCases := []struct {
          name         string
          projectFiles map[string]string
          expectedType entities.ProjectType
          minConfidence float64
      }{
          {
              name: "Web Application",
              projectFiles: map[string]string{
                  "package.json":    `{"dependencies": {"react": "^18.0.0"}}`,
                  "src/App.js":      "import React from 'react'",
                  "server/index.js": "const express = require('express')",
                  "public/index.html": "<html>",
              },
              expectedType:  entities.ProjectTypeWebApp,
              minConfidence: 0.8,
          },
          {
              name: "CLI Tool",
              projectFiles: map[string]string{
                  "main.go":    "package main",
                  "cmd/root.go": "cobra.Command",
                  "go.mod":     "module cli-tool",
              },
              expectedType:  entities.ProjectTypeCLI,
              minConfidence: 0.7,
          },
          {
              name: "API Service",
              projectFiles: map[string]string{
                  "main.go":            "package main",
                  "handlers/users.go":  "func GetUsers(w http.ResponseWriter",
                  "middleware/auth.go": "func AuthMiddleware",
                  "Dockerfile":         "FROM golang:1.19",
              },
              expectedType:  entities.ProjectTypeAPI,
              minConfidence: 0.8,
          },
      }
      
      for _, tc := range testCases {
          s.Run(tc.name, func() {
              // Create temp project directory
              tempDir := s.testData.CreateTempProject(tc.projectFiles)
              defer os.RemoveAll(tempDir)
              
              // Classify project
              projectType, confidence, err := classifier.ClassifyProject(
                  context.Background(), tempDir)
              
              s.Require().NoError(err)
              s.Assert().Equal(tc.expectedType, projectType)
              s.Assert().GreaterOrEqual(confidence, tc.minConfidence)
          })
      }
  }
  
  func (s *IntelligenceTestSuite) TestTemplateInstantiation() {
      ctx := context.Background()
      
      // Get built-in template
      templates := s.suggestionService.GetBuiltInTemplates()
      webAppTemplate := s.findTemplate(templates, entities.ProjectTypeWebApp)
      s.Require().NotNil(webAppTemplate)
      
      // Instantiate with variables
      vars := map[string]interface{}{
          "repository": "test-repo",
          "Framework":  "react",
          "Database":   "postgresql",
      }
      
      tasks, err := s.suggestionService.InstantiateTemplate(ctx, webAppTemplate.ID, vars)
      s.Require().NoError(err)
      s.Assert().NotEmpty(tasks)
      
      // Verify variable substitution
      frameworkTask := s.findTaskByContent(tasks, "react")
      s.Assert().NotNil(frameworkTask, "Should find task with React framework")
      
      dbTask := s.findTaskByContent(tasks, "postgresql")
      s.Assert().NotNil(dbTask, "Should find task with PostgreSQL database")
      
      // Verify dependencies
      for _, task := range tasks {
          if deps, ok := task.Metadata["depends_on"].([]string); ok {
              for _, depID := range deps {
                  depTask := s.findTaskByID(tasks, depID)
                  s.Assert().NotNil(depTask, "Dependency should exist")
              }
          }
      }
  }
  
  // Cross-repository tests
  func (s *IntelligenceTestSuite) TestCrossRepoPrivacy() {
      ctx := context.Background()
      
      // Create sensitive pattern
      sensitivePattern := &entities.TaskPattern{
          ID:       uuid.New().String(),
          Type:     entities.PatternTypeSequence,
          Name:     "Customer Data Migration",
          Repository: "private-repo",
          Metadata: map[string]interface{}{
              "keywords": []string{"customer", "ssn", "credit-card"},
          },
      }
      
      // Set privacy settings
      privacySettings := &services.PrivacySettings{
          SharePatterns:    true,
          ExcludeKeywords:  []string{"ssn", "credit-card", "password"},
          MinAnonymization: 3,
      }
      
      analyzer := services.NewCrossRepoAnalyzer(services.CrossRepoDeps{
          PatternStore: s.patternStore,
          Logger:       slog.Default(),
      })
      
      // Contribute pattern with privacy
      err := analyzer.ContributePattern(ctx, sensitivePattern, true)
      s.Require().NoError(err)
      
      // Verify anonymization
      sharedPatterns, err := analyzer.GetSharedInsights(ctx, entities.ProjectTypeWebApp)
      s.Require().NoError(err)
      
      for _, insight := range sharedPatterns {
          if insight.Pattern != nil {
              // Check keywords are filtered
              for _, keyword := range insight.Pattern.CommonKeywords {
                  s.Assert().NotContains(keyword, "ssn")
                  s.Assert().NotContains(keyword, "credit-card")
              }
          }
      }
  }
  
  // Analytics tests
  func (s *IntelligenceTestSuite) TestAnalyticsAccuracy() {
      ctx := context.Background()
      
      // Generate known dataset
      startDate := time.Now().AddDate(0, 0, -30)
      tasks := s.testData.GenerateTimeSeriesTasks("analytics-repo", startDate, 30, 5)
      
      completedCount := 0
      totalDuration := time.Duration(0)
      
      for _, task := range tasks {
          s.taskStore.Create(ctx, task)
          if task.Status == "completed" {
              completedCount++
              if duration, ok := task.Metadata["duration"].(time.Duration); ok {
                  totalDuration += duration
              }
          }
      }
      
      // Generate analytics
      period := entities.TimePeriod{
          Start: startDate,
          End:   time.Now(),
      }
      
      metrics, err := s.analyticsService.GetWorkflowMetrics(ctx, "analytics-repo", period)
      s.Require().NoError(err)
      
      // Verify accuracy
      expectedCompletionRate := float64(completedCount) / float64(len(tasks))
      s.Assert().InDelta(expectedCompletionRate, metrics.Completion.CompletionRate, 0.01)
      
      expectedTasksPerDay := float64(len(tasks)) / 30.0
      s.Assert().InDelta(expectedTasksPerDay, metrics.Productivity.TasksPerDay, 0.1)
  }
  
  // End-to-end workflow test
  func (s *IntelligenceTestSuite) TestIntelligenceWorkflow() {
      ctx := context.Background()
      
      // Step 1: Initialize new project
      projectPath := s.testData.CreateTempProject(map[string]string{
          "package.json": `{"name": "test-app", "dependencies": {"react": "^18.0.0"}}`,
          "src/index.js": "import React from 'react'",
      })
      defer os.RemoveAll(projectPath)
      
      // Step 2: Classify project and get template
      classifier := services.NewProjectClassifier(nil, slog.Default())
      projectType, _, err := classifier.ClassifyProject(ctx, projectPath)
      s.Require().NoError(err)
      s.Assert().Equal(entities.ProjectTypeWebApp, projectType)
      
      // Step 3: Get template suggestions
      templates, err := s.suggestionService.MatchTemplates(ctx, projectPath)
      s.Require().NoError(err)
      s.Assert().NotEmpty(templates)
      
      // Step 4: Instantiate template
      template := templates[0].Template
      tasks, err := s.suggestionService.InstantiateTemplate(ctx, template.ID, map[string]interface{}{
          "repository": "e2e-repo",
          "Framework":  "react",
          "Database":   "postgresql",
      })
      s.Require().NoError(err)
      
      // Step 5: Work on tasks and generate patterns
      for i, task := range tasks[:3] {
          // Simulate work
          task.Status = "completed"
          task.Metadata["completed_at"] = time.Now().Add(time.Duration(i) * time.Hour)
          s.taskStore.Update(ctx, task)
      }
      
      // Step 6: Detect patterns
      detector := services.NewPatternDetector(
          s.taskStore, s.patternStore, nil, slog.Default())
      
      allTasks, _ := s.taskStore.GetByRepository(ctx, "e2e-repo", nil)
      patterns, err := detector.DetectSequencePatterns(ctx, allTasks, 0.1)
      s.Require().NoError(err)
      
      // Step 7: Get intelligent suggestions
      suggestions, err := s.suggestionService.GenerateSuggestions(ctx, "e2e-repo")
      s.Require().NoError(err)
      s.Assert().NotEmpty(suggestions)
      
      // Step 8: Generate analytics
      metrics, err := s.analyticsService.GetWorkflowMetrics(ctx, "e2e-repo", entities.TimePeriod{
          Start: time.Now().AddDate(0, 0, -7),
          End:   time.Now(),
      })
      s.Require().NoError(err)
      s.Assert().Greater(metrics.Completion.CompletionRate, 0.0)
      
      s.T().Log("End-to-end intelligence workflow completed successfully")
  }
  
  // Test utilities
  type TestDataGenerator struct {
      random *rand.Rand
  }
  
  func NewTestDataGenerator() *TestDataGenerator {
      return &TestDataGenerator{
          random: rand.New(rand.NewSource(time.Now().UnixNano())),
      }
  }
  
  func (g *TestDataGenerator) GeneratePatternedTasks(
      repository string,
      patterns []PatternTemplate,
  ) []*entities.Task {
      var tasks []*entities.Task
      
      for _, pattern := range patterns {
          for i := 0; i < pattern.Count; i++ {
              baseTIme := time.Now().AddDate(0, 0, -30+i)
              for j, taskType := range pattern.Sequence {
                  task := &entities.Task{
                      ID:         uuid.New().String(),
                      Content:    fmt.Sprintf("%s task %d-%d", taskType, i, j),
                      Status:     "completed",
                      Priority:   "medium",
                      Repository: repository,
                      CreatedAt:  baseTIme.Add(time.Duration(j) * time.Hour),
                      UpdatedAt:  baseTIme.Add(time.Duration(j+1) * time.Hour),
                      Metadata: map[string]interface{}{
                          "type":     taskType,
                          "pattern":  pattern.Name,
                          "sequence": j,
                      },
                  }
                  tasks = append(tasks, task)
              }
          }
      }
      
      // Shuffle to simulate real-world disorder
      g.random.Shuffle(len(tasks), func(i, j int) {
          tasks[i], tasks[j] = tasks[j], tasks[i]
      })
      
      return tasks
  }
  
  func TestIntelligenceIntegration(t *testing.T) {
      suite.Run(t, new(IntelligenceTestSuite))
  }
  ```

- **Configuration Changes:** 
  - Add test data generation configuration
  - Configure test timeouts
  - Set performance benchmarks

- **Dependencies:**
  - All MT-004 sub-task implementations
  - Test data generation utilities
  - Integration test framework

## 4. Acceptance Criteria
- **Functional Criteria:**
  - All intelligence features have integration tests
  - Pattern detection accuracy validated
  - Suggestion relevance tested
  - Template system fully tested
  - Cross-repo privacy verified
  - Analytics accuracy confirmed
  - End-to-end workflow passes
  
- **Technical Criteria:**
  - Test coverage â‰¥90% for all features
  - Performance benchmarks established
  - Tests run in reasonable time (<5 minutes)
  - No flaky tests
  
- **Integration Criteria:**
  - Tests validate feature interactions
  - Data flow between components tested
  - Edge cases covered
  
- **Test Criteria:**
  - All tests pass consistently
  - Performance requirements met
  - Test data realistic
  - Failure scenarios tested

## 5. Testing Requirements
- **Unit Tests:** Not applicable (this is testing)
- **Integration Tests:** This entire sub-task
- **Manual Testing:** Run test suite in different environments
- **Test Data:**
  - Pattern templates for known sequences
  - Project samples for classification
  - Time-series task data
  - Privacy test scenarios

## 6. Definition of Done
- **Code Complete:** All integration tests implemented
- **Tests Passing:** 100% of tests passing consistently
- **Documentation Updated:** Test documentation and coverage reports
- **Integration Verified:** Tests cover all MT-004 features
- **Review Approved:** Test strategy and coverage reviewed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** All MT-004 sub-tasks must be complete
- **External Dependencies:** Test data generation utilities
- **Environmental Requirements:** Test environment setup
- **Potential Blockers:** Feature implementation changes affecting tests

## 8. Integration Notes
- **Component Interfaces:** Tests all MT-004 service interfaces
- **Data Flow:** Validates complete intelligence data flow
- **Error Handling:** Tests error scenarios and edge cases
- **Configuration Impact:** Test-specific configuration profiles