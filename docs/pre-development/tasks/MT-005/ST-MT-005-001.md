# ST-MT-005-001: Implement Bubble Tea Interactive TUI Framework

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-005-001
- **Sub-Task Name:** Implement Bubble Tea Interactive TUI Framework
- **Parent Task:** MT-005: Production-Ready System with Advanced Features
- **Estimated Duration:** 4 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Interactive Terminal UI application using Bubble Tea framework with full keyboard navigation
- **Code Location:** 
  - `cli/internal/tui/app.go` - Main TUI application
  - `cli/internal/tui/models/` - TUI model components
  - `cli/internal/tui/views/` - View components
  - `cli/internal/tui/styles/` - Styling and themes
  - `cli/internal/tui/components/` - Reusable UI components
- **Technical Requirements:** Bubble Tea framework, Lip Gloss styling, keyboard navigation, responsive layout
- **Interface Definition:** TUI application with task management, analytics dashboard, and settings

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Setup Bubble Tea application structure
  2. Create main model with application state
  3. Implement view switching and navigation
  4. Create task list view with filtering and sorting
  5. Add task detail view with editing
  6. Implement analytics dashboard view
  7. Create settings and configuration view
  8. Add keyboard shortcuts and help system
  9. Implement theme support (light/dark)
  10. Add responsive layout handling

- **Code Examples:**
  ```go
  // Main TUI application
  package tui
  
  import (
      "github.com/charmbracelet/bubbles/help"
      "github.com/charmbracelet/bubbles/key"
      "github.com/charmbracelet/bubbles/list"
      "github.com/charmbracelet/bubbles/textinput"
      "github.com/charmbracelet/bubbles/viewport"
      tea "github.com/charmbracelet/bubbletea"
      "github.com/charmbracelet/lipgloss"
  )
  
  type View string
  
  const (
      ViewTaskList     View = "tasks"
      ViewTaskDetail   View = "detail"
      ViewAnalytics    View = "analytics"
      ViewSettings     View = "settings"
      ViewHelp         View = "help"
  )
  
  type Model struct {
      // Core state
      currentView     View
      previousView    View
      width           int
      height          int
      
      // Services
      taskService     services.TaskService
      analyticsService services.AnalyticsService
      configService   services.ConfigService
      
      // Views
      taskList        list.Model
      taskDetail      *TaskDetailModel
      analytics       *AnalyticsModel
      settings        *SettingsModel
      
      // UI components
      help            help.Model
      keys            KeyMap
      statusBar       *StatusBar
      commandPalette  *CommandPalette
      
      // Application state
      repository      string
      filter          TaskFilter
      theme           Theme
      showHelp        bool
      err             error
  }
  
  type KeyMap struct {
      Up              key.Binding
      Down            key.Binding
      Left            key.Binding
      Right           key.Binding
      Enter           key.Binding
      Back            key.Binding
      Quit            key.Binding
      Help            key.Binding
      Filter          key.Binding
      Sort            key.Binding
      Create          key.Binding
      Edit            key.Binding
      Delete          key.Binding
      ToggleView      key.Binding
      CommandPalette  key.Binding
      Refresh         key.Binding
  }
  
  func NewKeyMap() KeyMap {
      return KeyMap{
          Up: key.NewBinding(
              key.WithKeys("up", "k"),
              key.WithHelp("‚Üë/k", "up"),
          ),
          Down: key.NewBinding(
              key.WithKeys("down", "j"),
              key.WithHelp("‚Üì/j", "down"),
          ),
          Enter: key.NewBinding(
              key.WithKeys("enter"),
              key.WithHelp("enter", "select"),
          ),
          Back: key.NewBinding(
              key.WithKeys("esc", "b"),
              key.WithHelp("esc/b", "back"),
          ),
          Quit: key.NewBinding(
              key.WithKeys("q", "ctrl+c"),
              key.WithHelp("q", "quit"),
          ),
          Help: key.NewBinding(
              key.WithKeys("?"),
              key.WithHelp("?", "help"),
          ),
          Create: key.NewBinding(
              key.WithKeys("n", "a"),
              key.WithHelp("n/a", "new task"),
          ),
          Edit: key.NewBinding(
              key.WithKeys("e"),
              key.WithHelp("e", "edit"),
          ),
          Delete: key.NewBinding(
              key.WithKeys("d"),
              key.WithHelp("d", "delete"),
          ),
          Filter: key.NewBinding(
              key.WithKeys("f", "/"),
              key.WithHelp("f", "filter"),
          ),
          CommandPalette: key.NewBinding(
              key.WithKeys("ctrl+p"),
              key.WithHelp("ctrl+p", "command"),
          ),
      }
  }
  
  func NewModel(deps Dependencies) Model {
      // Initialize task list
      items := []list.Item{}
      taskList := list.New(items, NewTaskDelegate(), 0, 0)
      taskList.Title = "Tasks"
      taskList.SetShowStatusBar(true)
      taskList.SetFilteringEnabled(true)
      taskList.Styles.Title = titleStyle
      
      return Model{
          currentView:      ViewTaskList,
          taskService:      deps.TaskService,
          analyticsService: deps.AnalyticsService,
          configService:    deps.ConfigService,
          taskList:         taskList,
          taskDetail:       NewTaskDetailModel(),
          analytics:        NewAnalyticsModel(deps.AnalyticsService),
          settings:         NewSettingsModel(deps.ConfigService),
          help:             help.New(),
          keys:             NewKeyMap(),
          statusBar:        NewStatusBar(),
          commandPalette:   NewCommandPalette(),
          repository:       deps.Repository,
          theme:            LoadTheme(deps.ConfigService.GetTheme()),
      }
  }
  
  func (m Model) Init() tea.Cmd {
      return tea.Batch(
          m.loadTasks(),
          tea.EnterAltScreen,
      )
  }
  
  func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
      var cmds []tea.Cmd
      
      switch msg := msg.(type) {
      case tea.WindowSizeMsg:
          m.width = msg.Width
          m.height = msg.Height
          m.updateLayout()
          
      case tea.KeyMsg:
          // Global key bindings
          switch {
          case key.Matches(msg, m.keys.Quit):
              if m.currentView != ViewTaskDetail || !m.taskDetail.IsEditing() {
                  return m, tea.Quit
              }
              
          case key.Matches(msg, m.keys.Help):
              m.showHelp = !m.showHelp
              return m, nil
              
          case key.Matches(msg, m.keys.CommandPalette):
              cmd := m.commandPalette.Toggle()
              return m, cmd
              
          case key.Matches(msg, m.keys.Back):
              if m.previousView != "" && m.currentView != ViewTaskList {
                  m.switchView(m.previousView)
                  return m, nil
              }
          }
          
          // View-specific updates
          cmd := m.updateCurrentView(msg)
          cmds = append(cmds, cmd)
          
      case TasksLoadedMsg:
          m.updateTaskList(msg.Tasks)
          
      case TaskUpdatedMsg:
          cmds = append(cmds, m.loadTasks())
          
      case ViewSwitchMsg:
          m.switchView(msg.View)
          
      case ErrorMsg:
          m.err = msg.Err
          m.statusBar.SetError(msg.Err)
      }
      
      // Update status bar
      m.statusBar.Update(m)
      
      return m, tea.Batch(cmds...)
  }
  
  func (m Model) View() string {
      if m.width == 0 || m.height == 0 {
          return "Loading..."
      }
      
      var content string
      
      switch m.currentView {
      case ViewTaskList:
          content = m.viewTaskList()
      case ViewTaskDetail:
          content = m.viewTaskDetail()
      case ViewAnalytics:
          content = m.viewAnalytics()
      case ViewSettings:
          content = m.viewSettings()
      case ViewHelp:
          content = m.viewHelp()
      }
      
      // Add status bar
      statusBar := m.statusBar.View(m.width)
      
      // Add help if shown
      if m.showHelp {
          helpView := m.help.View(m.keys)
          content = lipgloss.JoinVertical(
              lipgloss.Top,
              content,
              helpStyle.Render(helpView),
          )
      }
      
      // Combine all
      return lipgloss.JoinVertical(
          lipgloss.Top,
          content,
          statusBar,
      )
  }
  
  // Task list view
  func (m Model) viewTaskList() string {
      header := headerStyle.Render("üìã Task Management")
      
      // Quick stats
      stats := m.renderQuickStats()
      
      // Task list
      listHeight := m.height - lipgloss.Height(header) - lipgloss.Height(stats) - 2
      m.taskList.SetHeight(listHeight)
      
      return lipgloss.JoinVertical(
          lipgloss.Top,
          header,
          stats,
          m.taskList.View(),
      )
  }
  
  func (m Model) renderQuickStats() string {
      // Get task statistics
      total := len(m.taskList.Items())
      completed := 0
      inProgress := 0
      
      for _, item := range m.taskList.Items() {
          if task, ok := item.(TaskItem); ok {
              switch task.Status {
              case "completed":
                  completed++
              case "in_progress":
                  inProgress++
              }
          }
      }
      
      stats := lipgloss.JoinHorizontal(
          lipgloss.Top,
          statStyle.Render(fmt.Sprintf("Total: %d", total)),
          statDivider,
          statStyle.Render(fmt.Sprintf("In Progress: %d", inProgress)),
          statDivider,
          statStyle.Render(fmt.Sprintf("Completed: %d", completed)),
      )
      
      return statsContainerStyle.Render(stats)
  }
  
  // Task detail view
  type TaskDetailModel struct {
      task         *entities.Task
      viewport     viewport.Model
      titleInput   textinput.Model
      contentInput textinput.Model
      editing      bool
      focused      int
  }
  
  func (m *TaskDetailModel) View() string {
      if m.task == nil {
          return "No task selected"
      }
      
      var content string
      
      if m.editing {
          content = m.renderEditMode()
      } else {
          content = m.renderViewMode()
      }
      
      return lipgloss.JoinVertical(
          lipgloss.Top,
          headerStyle.Render("üìù Task Details"),
          content,
      )
  }
  
  // Analytics dashboard view  
  type AnalyticsModel struct {
      metrics     *entities.WorkflowMetrics
      chartView   viewport.Model
      period      string
      loading     bool
  }
  
  func (m *AnalyticsModel) View() string {
      if m.loading {
          return centerStyle.Render("Loading analytics...")
      }
      
      if m.metrics == nil {
          return centerStyle.Render("No analytics data available")
      }
      
      header := headerStyle.Render("üìä Analytics Dashboard")
      
      // Render charts
      charts := lipgloss.JoinVertical(
          lipgloss.Top,
          m.renderProductivityChart(),
          m.renderVelocityChart(),
          m.renderCompletionChart(),
      )
      
      m.chartView.SetContent(charts)
      
      return lipgloss.JoinVertical(
          lipgloss.Top,
          header,
          m.chartView.View(),
      )
  }
  
  // Theme support
  type Theme struct {
      Primary     lipgloss.Color
      Secondary   lipgloss.Color
      Background  lipgloss.Color
      Foreground  lipgloss.Color
      Success     lipgloss.Color
      Warning     lipgloss.Color
      Error       lipgloss.Color
      Muted       lipgloss.Color
  }
  
  var (
      lightTheme = Theme{
          Primary:    lipgloss.Color("#007ACC"),
          Secondary:  lipgloss.Color("#40A9FF"),
          Background: lipgloss.Color("#FFFFFF"),
          Foreground: lipgloss.Color("#000000"),
          Success:    lipgloss.Color("#52C41A"),
          Warning:    lipgloss.Color("#FAAD14"),
          Error:      lipgloss.Color("#F5222D"),
          Muted:      lipgloss.Color("#8C8C8C"),
      }
      
      darkTheme = Theme{
          Primary:    lipgloss.Color("#1890FF"),
          Secondary:  lipgloss.Color("#69C0FF"),
          Background: lipgloss.Color("#000000"),
          Foreground: lipgloss.Color("#FFFFFF"),
          Success:    lipgloss.Color("#73D13D"),
          Warning:    lipgloss.Color("#FFEC3D"),
          Error:      lipgloss.Color("#FF4D4F"),
          Muted:      lipgloss.Color("#595959"),
      }
  )
  
  // Styles
  var (
      titleStyle = lipgloss.NewStyle().
          Bold(true).
          Foreground(lipgloss.Color("#007ACC")).
          MarginLeft(2)
          
      headerStyle = lipgloss.NewStyle().
          Bold(true).
          Foreground(lipgloss.Color("#FFFFFF")).
          Background(lipgloss.Color("#007ACC")).
          Padding(0, 1).
          Width(80)
          
      statStyle = lipgloss.NewStyle().
          Padding(0, 2)
          
      statDivider = lipgloss.NewStyle().
          Foreground(lipgloss.Color("#666666")).
          Render("‚îÇ")
          
      statsContainerStyle = lipgloss.NewStyle().
          Border(lipgloss.RoundedBorder()).
          BorderForeground(lipgloss.Color("#666666")).
          Padding(0, 1).
          MarginTop(1).
          MarginBottom(1)
  )
  
  // Command palette
  type CommandPalette struct {
      input    textinput.Model
      commands []Command
      filtered []Command
      selected int
      active   bool
  }
  
  type Command struct {
      Name        string
      Description string
      Shortcut    string
      Action      tea.Cmd
  }
  
  func NewCommandPalette() *CommandPalette {
      input := textinput.New()
      input.Placeholder = "Type a command..."
      input.CharLimit = 50
      
      return &CommandPalette{
          input: input,
          commands: []Command{
              {Name: "New Task", Description: "Create a new task", Shortcut: "n"},
              {Name: "View Analytics", Description: "Open analytics dashboard", Shortcut: "a"},
              {Name: "Settings", Description: "Open settings", Shortcut: "s"},
              {Name: "Export Tasks", Description: "Export tasks to file", Shortcut: "e"},
              {Name: "Sync", Description: "Sync with server", Shortcut: "r"},
          },
      }
  }
  
  // Run the TUI
  func RunTUI(deps Dependencies) error {
      p := tea.NewProgram(
          NewModel(deps),
          tea.WithAltScreen(),
          tea.WithMouseCellMotion(),
      )
      
      if _, err := p.Run(); err != nil {
          return fmt.Errorf("TUI error: %w", err)
      }
      
      return nil
  }
  ```

- **Configuration Changes:** 
  - Add TUI theme configuration
  - Configure keyboard shortcuts
  - Set default view preferences

- **Dependencies:**
  - `github.com/charmbracelet/bubbletea`
  - `github.com/charmbracelet/bubbles`
  - `github.com/charmbracelet/lipgloss`

## 4. Acceptance Criteria
- **Functional Criteria:**
  - TUI launches successfully with all views
  - Task list displays with filtering and sorting
  - Task details can be viewed and edited
  - Analytics dashboard shows visualizations
  - Settings can be modified
  - Keyboard navigation works throughout
  - Help system is accessible
  - Theme switching works
  
- **Technical Criteria:**
  - Responsive to terminal size changes
  - Smooth navigation between views
  - No UI freezing during operations
  - Memory efficient with large task lists
  - Keyboard shortcuts are consistent
  
- **Integration Criteria:**
  - Integrates with all existing services
  - Real-time updates from server
  - Works alongside CLI commands
  
- **Test Criteria:**
  - All views render correctly
  - Navigation flows tested
  - Keyboard shortcuts verified
  - Edge cases handled

## 5. Testing Requirements
- **Unit Tests:**
  - Model update logic
  - View rendering functions
  - Command processing
  - State management
  - Theme application
  
- **Integration Tests:**
  - Full TUI lifecycle
  - Service integration
  - Data flow validation
  - Error handling
  
- **Manual Testing:**
  - Visual inspection of all views
  - Keyboard navigation testing
  - Different terminal sizes
  - Theme switching
  
- **Test Data:**
  - Various task datasets
  - Analytics data samples
  - Configuration scenarios

## 6. Definition of Done
- **Code Complete:** Complete TUI application with all views
- **Tests Passing:** Unit and integration tests passing (‚â•80% coverage)
- **Documentation Updated:** TUI usage guide and shortcuts documented
- **Integration Verified:** Works with all services and data
- **Review Approved:** UX review completed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** None (foundational for MT-005)
- **External Dependencies:** Bubble Tea framework and components
- **Environmental Requirements:** Terminal with UTF-8 and color support
- **Potential Blockers:** Terminal compatibility issues

## 8. Integration Notes
- **Component Interfaces:** Uses all existing services
- **Data Flow:** Services ‚Üí Model ‚Üí View ‚Üí Terminal
- **Error Handling:** User-friendly error displays
- **Configuration Impact:** New TUI preferences section